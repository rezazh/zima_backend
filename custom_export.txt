

====== FILE: templates/chat/admin_dashboard.html ======

{% extends "base/base.html" %}
{% load static %}

{% block title %}داشبورد چت - مدیریت{% endblock %}

{% block extra_css %}
<style>
    .admin-dashboard {
        padding: 20px;
    }

    .dashboard-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    .stat-card {
        background-color: #fff;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        padding: 20px;
        text-align: center;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .stat-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .stat-value {
        font-size: 36px;
        font-weight: bold;
        margin-bottom: 10px;
    }

    .stat-label {
        color: #6c757d;
        font-size: 14px;
    }

    .stat-card:nth-child(1) .stat-value {
        color: #28a745;
    }

    .stat-card:nth-child(2) .stat-value {
        color: #ffc107;
    }

    .stat-card:nth-child(3) .stat-value {
        color: #17a2b8;
    }

    .stat-card:nth-child(4) .stat-value {
        color: #6f42c1;
    }

    .chat-section {
        margin-bottom: 40px;
    }

    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e9ecef;
    }

    .section-header h2 {
        margin: 0;
        font-size: 24px;
        color: #343a40;
    }

    .chat-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
    }

    .chat-item {
        background-color: #fff;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        padding: 20px;
        position: relative;
        transition: transform 0.2s ease;
    }

    .chat-item:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .chat-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
    }

    .chat-title {
        font-weight: bold;
        color: #343a40;
        font-size: 16px;
    }

    .chat-time {
        color: #6c757d;
        font-size: 12px;
    }

    .chat-user {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .user-avatar {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background-color: #e9ecef;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: 10px;
        color: #6c757d;
        font-size: 14px;
    }

    .chat-preview {
        background-color: #f8f9fa;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        margin-bottom: 15px;
        color: #495057;
        max-height: 60px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .chat-actions {
        display: flex;
        justify-content: flex-end;
    }

    .badge {
        padding: 5px 10px;
        border-radius: 50px;
        font-size: 12px;
        font-weight: normal;
    }

    .badge-warning {
        background-color: #ffc107;
        color: #212529;
    }

    .badge-success {
        background-color: #28a745;
        color: white;
    }

    .badge-danger {
        background-color: #dc3545;
        color: white;
    }

    .badge-secondary {
        background-color: #6c757d;
        color: white;
    }

    .empty-state {
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 30px;
        text-align: center;
        color: #6c757d;
    }

    .chat-closed-time {
        font-size: 12px;
        color: #dc3545;
        margin-bottom: 10px;
    }

    .unread-badge {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: #dc3545;
        color: white;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
    }

    /* نشانگر آنلاین بودن */
    .online-status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-left: 5px;
    }

    .online {
        background-color: #28a745;
    }

    .offline {
        background-color: #dc3545;
    }

    /* تب‌های فیلتر */
    .filter-tabs {
        display: flex;
        margin-bottom: 20px;
        background-color: #f8f9fa;
        border-radius: 10px;
        overflow: hidden;
    }

    .filter-tab {
        padding: 10px 20px;
        cursor: pointer;
        text-align: center;
        flex-grow: 1;
        transition: background-color 0.2s;
    }

    .filter-tab.active {
        background-color: #007bff;
        color: white;
    }

    .filter-tab:hover:not(.active) {
        background-color: #e9ecef;
    }

    /* جستجو */
    .search-container {
        margin-bottom: 20px;
    }

    .search-input {
        width: 100%;
        padding: 10px 15px;
        border: 1px solid #ced4da;
        border-radius: 5px;
        font-size: 14px;
    }

    .search-input:focus {
        border-color: #80bdff;
        outline: 0;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
</style>
{% endblock %}

{% block content %}
<div class="admin-dashboard">
    <h1>داشبورد مدیریت چت</h1>

    <div class="dashboard-stats">
        <div class="stat-card">
            <div class="stat-value">{{ active_chats }}</div>
            <div class="stat-label">چت‌های فعال</div>
        </div>

        <div class="stat-card">
            <div class="stat-value">{{ pending_chats }}</div>
            <div class="stat-label">چت‌های در انتظار</div>
        </div>

        <div class="stat-card">
            <div class="stat-value">{{ online_users }}</div>
            <div class="stat-label">کاربران آنلاین</div>
        </div>

        <div class="stat-card">
            <div class="stat-value">{{ user_closed_chats|length }}</div>
            <div class="stat-label">چت‌های بسته شده توسط کاربر</div>
        </div>
    </div>

    <div class="search-container">
        <input type="text" id="chat-search" class="search-input" placeholder="جستجو در گفتگوها...">
    </div>

    <div class="filter-tabs">
        <div class="filter-tab active" data-filter="all">همه</div>
        <div class="filter-tab" data-filter="pending">در انتظار</div>
        <div class="filter-tab" data-filter="active">فعال</div>
        <div class="filter-tab" data-filter="closed-user">بسته شده توسط کاربر</div>
        <div class="filter-tab" data-filter="closed-admin">بسته شده توسط پشتیبانی</div>
    </div>

    <div class="chat-section">
        <div class="section-header">
            <h2>چت‌های در انتظار پاسخ</h2>
            <button id="refresh-pending" class="btn btn-sm btn-outline-primary">
                <i class="fas fa-sync"></i> بروزرسانی
            </button>
        </div>
        <div class="chat-list pending-chats" id="pending-chats-container">
            {% if pending_rooms %}
                {% for room in pending_rooms %}
                    <div class="chat-item" data-chat-type="pending" data-username="{{ room.user.username|default:'' }}" data-content="{{ room.messages.last.content|default:'' }}">
                        <div class="chat-header">
                            <span class="chat-title">{{ room.name }} <span class="badge badge-warning">در انتظار</span></span>
                            <span class="chat-time">{{ room.created_at|date:"Y/m/d H:i" }}</span>
                        </div>
                        <div class="chat-user">
                            <div class="user-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            {% if room.user %}
                                {{ room.user.get_full_name|default:room.user.username }}
                                {% if room.user_status.is_online %}
                                    <span class="online-status online" title="کاربر آنلاین است"></span>
                                {% else %}
                                    <span class="online-status offline" title="کاربر آفلاین است"></span>
                                {% endif %}
                            {% else %}
                                کاربر ناشناس
                            {% endif %}
                        </div>
                        {% if room.messages.last %}
                            <div class="chat-preview">
                                {{ room.messages.last.content|truncatechars:50 }}
                            </div>
                        {% endif %}
                        <div class="chat-actions">
                            <a href="{% url 'chat:chat_room' room.id %}" class="btn btn-primary">پاسخ</a>
                        </div>
                    </div>
                {% endfor %}
            {% else %}
                <div class="empty-state">
                    <i class="fas fa-check-circle fa-3x mb-3"></i>
                    <p>چت در انتظاری وجود ندارد.</p>
                </div>
            {% endif %}
        </div>
    </div>

    <div class="chat-section">
        <div class="section-header">
            <h2>چت‌های فعال شما</h2>
            <button id="refresh-active" class="btn btn-sm btn-outline-primary">
                <i class="fas fa-sync"></i> بروزرسانی
            </button>
        </div>
        <div class="chat-list active-chats" id="active-chats-container">
            {% if admin_active_chats %}
                {% for room in admin_active_chats %}
                    <div class="chat-item" data-chat-type="active" data-username="{{ room.user.username|default:'' }}" data-content="{{ room.messages.last.content|default:'' }}">
                        <div class="chat-header">
                            <span class="chat-title">{{ room.name }} <span class="badge badge-success">فعال</span></span>
                            <span class="chat-time">{{ room.updated_at|date:"Y/m/d H:i" }}</span>
                        </div>
                        {% if room.unread_count > 0 %}
                            <div class="unread-badge">{{ room.unread_count }}</div>
                        {% endif %}
                        <div class="chat-user">
                            <div class="user-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            {% if room.user %}
                                {{ room.user.get_full_name|default:room.user.username }}
                                {% if room.user_status.is_online %}
                                    <span class="online-status online" title="کاربر آنلاین است"></span>
                                {% else %}
                                    <span class="online-status offline" title="کاربر آفلاین است"></span>
                                {% endif %}
                            {% else %}
                                کاربر ناشناس
                            {% endif %}
                        </div>
                        {% if room.messages.last %}
                            <div class="chat-preview">
                                {{ room.messages.last.content|truncatechars:50 }}
                            </div>
                        {% endif %}
                        <div class="chat-actions">
                            <a href="{% url 'chat:chat_room' room.id %}" class="btn btn-primary">ادامه چت</a>
                        </div>
                    </div>
                {% endfor %}
            {% else %}
                <div class="empty-state">
                    <i class="fas fa-comments fa-3x mb-3"></i>
                    <p>شما هیچ چت فعالی ندارید.</p>
                </div>
            {% endif %}
        </div>
    </div>

    <div class="chat-section">
        <div class="section-header">
            <h2>چت‌های بسته شده توسط کاربر</h2>
            <button id="refresh-user-closed" class="btn btn-sm btn-outline-primary">
                <i class="fas fa-sync"></i> بروزرسانی
            </button>
        </div>
        <div class="chat-list closed-chats" id="user-closed-chats-container">
            {% if user_closed_chats %}
                {% for room in user_closed_chats %}
                    <div class="chat-item" data-chat-type="closed-user" data-username="{{ room.user.username|default:'' }}" data-content="{{ room.messages.last.content|default:'' }}">
                        <div class="chat-header">
                            <span class="chat-title">{{ room.name }} <span class="badge badge-secondary">بسته شده توسط کاربر</span></span>
                            <span class="chat-time">{{ room.updated_at|date:"Y/m/d H:i" }}</span>
                        </div>
                        <div class="chat-user">
                            <div class="user-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            {% if room.user %}
                                {{ room.user.get_full_name|default:room.user.username }}
                            {% else %}
                                کاربر ناشناس
                            {% endif %}
                        </div>
                        {% if room.closed_at %}
                            <div class="chat-closed-time">
                                <i class="fas fa-lock"></i> بسته شده در: {{ room.closed_at|date:"Y/m/d H:i" }}
                            </div>
                        {% endif %}
                        {% if room.messages.last %}
                            <div class="chat-preview">
                                {{ room.messages.last.content|truncatechars:50 }}
                            </div>
                        {% endif %}
                        <div class="chat-actions">
                            <a href="{% url 'chat:chat_room' room.id %}" class="btn btn-secondary">مشاهده</a>
                        </div>
                    </div>
                {% endfor %}
            {% else %}
                <div class="empty-state">
                    <i class="fas fa-comment-slash fa-3x mb-3"></i>
                    <p>چت بسته شده‌ای توسط کاربران وجود ندارد.</p>
                </div>
            {% endif %}
        </div>
    </div>

    <div class="chat-section">
        <div class="section-header">
            <h2>چت‌های بسته شده توسط پشتیبانی</h2>
            <button id="refresh-admin-closed" class="btn btn-sm btn-outline-primary">
                <i class="fas fa-sync"></i> بروزرسانی
            </button>
        </div>
        <div class="chat-list closed-chats" id="admin-closed-chats-container">
            {% if admin_closed_chats %}
                {% for room in admin_closed_chats %}
                    <div class="chat-item" data-chat-type="closed-admin" data-username="{{ room.user.username|default:'' }}" data-content="{{ room.messages.last.content|default:'' }}">
                        <div class="chat-header">
                            <span class="chat-title">{{ room.name }} <span class="badge badge-danger">بسته شده توسط پشتیبانی</span></span>
                            <span class="chat-time">{{ room.updated_at|date:"Y/m/d H:i" }}</span>
                        </div>
                        <div class="chat-user">
                            <div class="user-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            {% if room.user %}
                                {{ room.user.get_full_name|default:room.user.username }}
                            {% else %}
                                کاربر ناشناس
                            {% endif %}
                        </div>
                        {% if room.closed_at %}
                            <div class="chat-closed-time">
                                <i class="fas fa-lock"></i> بسته شده در: {{ room.closed_at|date:"Y/m/d H:i" }}
                            </div>
                        {% endif %}
                        {% if room.messages.last %}
                            <div class="chat-preview">
                                {{ room.messages.last.content|truncatechars:50 }}
                            </div>
                        {% endif %}
                        <div class="chat-actions">
                            <a href="{% url 'chat:chat_room' room.id %}" class="btn btn-secondary">مشاهده</a>
                        </div>
                    </div>
                {% endfor %}
            {% else %}
                <div class="empty-state">
                    <i class="fas fa-comment-slash fa-3x mb-3"></i>
                    <p>چت بسته شده‌ای توسط پشتیبانی وجود ندارد.</p>
                </div>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // وب‌سوکت برای اعلان‌های آنلاین
    const notificationSocket = new WebSocket(
        (window.location.protocol === 'https:' ? 'wss://' : 'ws://') +
        window.location.host +
        '/ws/notifications/'
    );

    notificationSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);

        // اگر اعلان جدید مربوط به چت دریافت کردیم
        if (data.type === 'notification' && data.notification_type === 'chat') {
            // بروزرسانی بخش‌های مربوطه
            refreshPendingChats();
            refreshActiveChats();
        }
    };

    // برای جلوگیری از قطع شدن اتصال، هر 30 ثانیه یک پیام heartbeat ارسال می‌کنیم
    setInterval(function() {
        if (notificationSocket.readyState === WebSocket.OPEN) {
            notificationSocket.send(JSON.stringify({
                'type': 'heartbeat'
            }));
        }
    }, 30000);

    // بروزرسانی بخش چت‌های در انتظار
    function refreshPendingChats() {
        fetch('{% url "chat:api_pending_chats" %}')
            .then(response => response.json())
            .then(data => {
                // بروزرسانی محتوای بخش چت‌های در انتظار
                updatePendingChatsSection(data);
                applyFilters(); // اعمال فیلترهای فعلی روی داده‌های جدید
            });
    }

    // بروزرسانی بخش چت‌های فعال
    function refreshActiveChats() {
        fetch('{% url "chat:api_active_chats" %}')
            .then(response => response.json())
            .then(data => {
                // بروزرسانی محتوای بخش چت‌های فعال
                updateActiveChatsSection(data);
                applyFilters(); // اعمال فیلترهای فعلی روی داده‌های جدید
            });
    }

    // بروزرسانی بخش چت‌های بسته شده توسط کاربر
    function refreshUserClosedChats() {
        fetch('{% url "chat:api_user_closed_chats" %}')
            .then(response => response.json())
            .then(data => {
                // بروزرسانی محتوای بخش چت‌های بسته شده توسط کاربر
                updateUserClosedChatsSection(data);
                applyFilters(); // اعمال فیلترهای فعلی روی داده‌های جدید
            });
    }

    // تابع بروزرسانی بخش چت‌های در انتظار
    function updatePendingChatsSection(data) {
        const container = document.getElementById('pending-chats-container');
        if (data.pending_chats && data.pending_chats.length > 0) {
            let html = '';
            data.pending_chats.forEach(room => {
                html += `
                    <div class="chat-item" data-chat-type="pending" data-username="${room.user_username || ''}" data-content="${room.last_message || ''}">
                        <div class="chat-header">
                            <span class="chat-title">${room.name} <span class="badge badge-warning">در انتظار</span></span>
                            <span class="chat-time">${formatDate(room.created_at)}</span>
                        </div>
                        <div class="chat-user">
                            <div class="user-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            ${room.user_name || 'کاربر ناشناس'}
                            ${room.user_online ? '<span class="online-status online" title="کاربر آنلاین است"></span>' : '<span class="online-status offline" title="کاربر آفلاین است"></span>'}
                        </div>
                        ${room.last_message ? `<div class="chat-preview">${room.last_message}</div>` : ''}
                        <div class="chat-actions">
                            <a href="/chat/room/${room.id}/" class="btn btn-primary">پاسخ</a>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        } else {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-check-circle fa-3x mb-3"></i>
                    <p>چت در انتظاری وجود ندارد.</p>
                </div>
            `;
        }
    }

    // تابع بروزرسانی بخش چت‌های فعال
    function updateActiveChatsSection(data) {
        const container = document.getElementById('active-chats-container');
        if (data.active_chats && data.active_chats.length > 0) {
            let html = '';
            data.active_chats.forEach(room => {
                html += `
                    <div class="chat-item" data-chat-type="active" data-username="${room.user_username || ''}" data-content="${room.last_message || ''}">
                        <div class="chat-header">
                            <span class="chat-title">${room.name} <span class="badge badge-success">فعال</span></span>
                            <span class="chat-time">${formatDate(room.updated_at)}</span>
                        </div>
                        ${room.unread_count > 0 ? `<div class="unread-badge">${room.unread_count}</div>` : ''}
                        <div class="chat-user">
                            <div class="user-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            ${room.user_name || 'کاربر ناشناس'}
                            ${room.user_online ? '<span class="online-status online" title="کاربر آنلاین است"></span>' : '<span class="online-status offline" title="کاربر آفلاین است"></span>'}
                        </div>
                        ${room.last_message ? `<div class="chat-preview">${room.last_message}</div>` : ''}
                        <div class="chat-actions">
                            <a href="/chat/room/${room.id}/" class="btn btn-primary">ادامه چت</a>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        } else {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-comments fa-3x mb-3"></i>
                    <p>شما هیچ چت فعالی ندارید.</p>
                </div>
            `;
        }
    }

    // تابع بروزرسانی بخش چت‌های بسته شده توسط کاربر
    function updateUserClosedChatsSection(data) {
        const container = document.getElementById('user-closed-chats-container');
        if (data.user_closed_chats && data.user_closed_chats.length > 0) {
            let html = '';
            data.user_closed_chats.forEach(room => {
                html += `
                    <div class="chat-item" data-chat-type="closed-user" data-username="${room.user_username || ''}" data-content="${room.last_message || ''}">
                        <div class="chat-header">
                            <span class="chat-title">${room.name} <span class="badge badge-secondary">بسته شده توسط کاربر</span></span>
                            <span class="chat-time">${formatDate(room.updated_at)}</span>
                        </div>
                        <div class="chat-user">
                            <div class="user-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            ${room.user_name || 'کاربر ناشناس'}
                        </div>
                        ${room.closed_at ? `<div class="chat-closed-time"><i class="fas fa-lock"></i> بسته شده در: ${formatDate(room.closed_at)}</div>` : ''}
                        ${room.last_message ? `<div class="chat-preview">${room.last_message}</div>` : ''}
                        <div class="chat-actions">
                            <a href="/chat/room/${room.id}/" class="btn btn-secondary">مشاهده</a>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        } else {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-comment-slash fa-3x mb-3"></i>
                    <p>چت بسته شده‌ای توسط کاربران وجود ندارد.</p>
                </div>
            `;
        }
    }

    // تبدیل تاریخ به فرمت مناسب
    function formatDate(dateString) {
        const date = new Date(dateString);
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');

        return `${year}/${month}/${day} ${hours}:${minutes}`;
    }

    // رویدادهای دکمه‌های بروزرسانی
    document.getElementById('refresh-pending').addEventListener('click', refreshPendingChats);
    document.getElementById('refresh-active').addEventListener('click', refreshActiveChats);
    document.getElementById('refresh-user-closed').addEventListener('click', refreshUserClosedChats);
    document.getElementById('refresh-admin-closed').addEventListener('click', function() {
        // این بخش نیاز به API دارد که در فایل urls.py شما موجود نیست
        window.location.reload();
    });

    // بروزرسانی خودکار هر 30 ثانیه
    setInterval(refreshPendingChats, 30000);
    setInterval(refreshActiveChats, 30000);

    // فیلتر کردن چت‌ها
    const searchInput = document.getElementById('chat-search');
    let currentFilter = 'all';

    searchInput.addEventListener('input', applyFilters);

    // تب‌های فیلتر
    document.querySelectorAll('.filter-tab').forEach(tab => {
        tab.addEventListener('click', function() {
            document.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            currentFilter = this.dataset.filter;
            applyFilters();
        });
    });

    function applyFilters() {
        const searchTerm = searchInput.value.toLowerCase();
        const allChatItems = document.querySelectorAll('.chat-item');

        allChatItems.forEach(item => {
            // بررسی فیلتر نوع چت
            const chatType = item.dataset.chatType;
            const typeMatch = currentFilter === 'all' || chatType === currentFilter;

            // بررسی فیلتر جستجو
            const username = item.dataset.username.toLowerCase();
            const content = item.dataset.content.toLowerCase();
            const searchMatch = username.includes(searchTerm) || content.includes(searchTerm);

            // نمایش یا مخفی کردن آیتم
            if (typeMatch && searchMatch) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });

        // بررسی وضعیت خالی بودن هر بخش پس از فیلتر
        checkEmptyState('pending-chats-container');
        checkEmptyState('active-chats-container');
        checkEmptyState('user-closed-chats-container');
        checkEmptyState('admin-closed-chats-container');
    }

    function checkEmptyState(containerId) {
        const container = document.getElementById(containerId);
        const visibleItems = container.querySelectorAll('.chat-item:not([style*="display: none"])');

        // اگر هیچ آیتمی بعد از فیلتر نمایش داده نمی‌شود
        if (visibleItems.length === 0) {
            // اگر قبلاً empty state نداریم، اضافه کنیم
            if (!container.querySelector('.empty-state')) {
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-state';
                emptyState.innerHTML = '<p>موردی یافت نشد.</p>';
                container.appendChild(emptyState);
            }
        } else {
            // اگر empty state داریم و آیتم‌های نمایشی هم داریم، empty state را حذف کنیم
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
        }
    }
</script>
{% endblock %}

====== FILE: templates/chat/chat_room.html ======

{% extends "base/base.html" %}
{% load static %}

{% block title %}گفتگو با پشتیبانی{% endblock %}

{% block extra_css %}
<style>
    .chat-container {
        max-width: 800px;
        margin: 0 auto;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        overflow: hidden;
    }

    .chat-header {
        background-color: #f8f9fa;
        padding: 15px;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .chat-title {
        font-weight: bold;
        font-size: 1.1rem;
    }

    .back-btn {
        color: #6c757d;
        text-decoration: none;
        margin-left: 15px;
    }

    .user-status {
        display: flex;
        align-items: center;
        font-size: 0.9rem;
        color: #6c757d;
    }

    .status-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-left: 5px;
    }

    .status-indicator.online {
        background-color: #28a745;
    }

    .status-indicator.offline {
        background-color: #dc3545;
    }

    .chat-status-badge {
        padding: 10px 15px;
        background-color: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
    }

    .chat-actions {
        padding: 10px 15px;
        background-color: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
        text-align: left;
    }

    .chat-closed-alert {
        margin: 10px 15px;
    }

    .chat-messages {
        padding: 15px;
        height: 400px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }

    .message {
        max-width: 80%;
        margin-bottom: 15px;
        padding: 10px 15px;
        border-radius: 18px;
        position: relative;
    }

    .message.sent {
        align-self: flex-end;
        background-color: #dcf8c6;
        border-bottom-right-radius: 5px;
    }

    .message.received {
        align-self: flex-start;
        background-color: #f1f0f0;
        border-bottom-left-radius: 5px;
    }

    .message.system-message {
        align-self: center;
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 5px 15px;
        font-size: 0.9rem;
        color: #6c757d;
        max-width: 90%;
    }

    .message-content {
        word-wrap: break-word;
    }

    .message-meta {
        display: flex;
        justify-content: flex-end;
        margin-top: 5px;
        font-size: 0.75rem;
        color: #6c757d;
    }

    .message-time {
        margin-left: 5px;
    }

    .read-status {
        margin-right: 5px;
    }

    .read-status.read {
        color: #3498db;
    }

    .read-status.unread {
        color: #95a5a6;
    }

    .message-file {
        margin-bottom: 5px;
    }

    .image-file img {
        max-width: 100%;
        border-radius: 5px;
        margin-bottom: 5px;
    }

    .file-link {
        display: flex;
        align-items: center;
        color: #3498db;
        text-decoration: none;
    }

    .file-link i {
        margin-left: 5px;
        font-size: 1.2rem;
    }

    .file-info {
        font-size: 0.8rem;
        color: #6c757d;
        margin-top: 3px;
    }

    .chat-input-container {
        padding: 15px;
        border-top: 1px solid #e9ecef;
    }

    .chat-form {
        display: flex;
        flex-direction: column;
    }

    .file-preview {
        margin-bottom: 10px;
        display: none;
    }

    .file-preview-item {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 10px;
        display: flex;
        align-items: center;
        position: relative;
    }

    .image-preview {
        max-width: 60px;
        max-height: 60px;
        border-radius: 5px;
        margin-left: 10px;
    }

    .file-icon {
        width: 40px;
        height: 40px;
        background-color: #e9ecef;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-left: 10px;
        color: #6c757d;
    }

    .remove-file-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        border: none;
        background: none;
        color: #dc3545;
        font-size: 1.2rem;
        cursor: pointer;
    }

    .input-group {
        display: flex;
    }

    #chat-input {
        flex-grow: 1;
        border-top-left-radius: 0;
        border-bottom-left-radius: 0;
    }

    .input-group-append {
        display: flex;
    }

    .input-group-append button {
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
    }
</style>
{% endblock %}

{% block content %}
<div class="chat-container">
    <div class="chat-header">
        <a href="{% if user.is_staff %}{% url 'chat:admin_dashboard' %}{% else %}{% url 'chat:chat_list' %}{% endif %}" class="back-btn">
            <i class="fas fa-arrow-left"></i> برگشت
        </a>

        <div class="chat-title">
            {% if room.is_closed_by_user %}
                گفتگوی بسته شده توسط کاربر
            {% elif room.is_closed_by_admin %}
                گفتگوی بسته شده توسط پشتیبانی
            {% else %}
                {% if user.is_staff %}
                    {{ room.user.username }}
                {% else %}
                    پشتیبانی
                {% endif %}
            {% endif %}
        </div>

        <div class="user-status" id="chat-status">
            <span class="status-indicator offline"></span> آفلاین
        </div>
    </div>

    <div class="chat-status-badge">
        {% if not room.is_closed_by_user and not room.is_closed_by_admin %}
            <span class="badge badge-success">فعال</span>
        {% elif room.is_closed_by_user %}
            <span class="badge badge-warning">بسته شده توسط کاربر</span>
        {% elif room.is_closed_by_admin %}
            <span class="badge badge-danger">بسته شده توسط پشتیبانی</span>
        {% endif %}
    </div>

    <div class="chat-actions">
        {% if user.is_staff %}
            {% if not room.is_closed_by_admin and not room.is_closed_by_user %}
                <button type="button" class="btn btn-danger" id="close-chat-btn" data-room-id="{{ room.id }}">بستن گفتگو</button>
            {% elif room.is_closed_by_user and not room.is_closed_by_admin %}
                <!-- اختیاری: دکمه بستن چت توسط ادمین حتی اگر کاربر بسته باشد -->
                <button type="button" class="btn btn-secondary" id="close-chat-btn" data-room-id="{{ room.id }}">بستن گفتگو توسط پشتیبانی</button>
            {% elif room.is_closed_by_admin %}
                <!-- چت قبلاً توسط ادمین بسته شده است -->
            {% endif %}
        {% else %}
            {% if not room.is_closed_by_user and not room.is_closed_by_admin %}
                <button type="button" class="btn btn-warning" id="close-chat-btn" data-room-id="{{ room.id }}">بستن گفتگو</button>
            {% else %}
                <!-- چت قبلاً بسته شده است -->
            {% endif %}
        {% endif %}
    </div>

    {% if room.is_closed_by_admin %}
        <div class="alert alert-danger chat-closed-alert">
            این گفتگو توسط پشتیبانی بسته شده است و امکان ارسال پیام جدید وجود ندارد.
        </div>
    {% elif room.is_closed_by_user and user.is_staff %}
        <div class="alert alert-warning chat-closed-alert">
            این گفتگو توسط کاربر بسته شده است. شما می‌توانید پیام‌ها را مشاهده کنید اما امکان ارسال پیام جدید وجود ندارد.
        </div>
    {% endif %}

    <div class="chat-messages" id="chat-messages">
        {% for message in chat_messages %}
            {% if message.message_type == 'system' %}
                <div class="message system-message">
                    <div class="message-content">{{ message.content }}</div>
                </div>
            {% else %}
                <div class="message {% if message.sender == request.user %}sent{% else %}received{% endif %}" id="msg-{{ message.id }}">
                    {% if message.message_type == 'image' %}
                        <div class="message-file image-file">
                            <img src="{{ message.file.url }}" alt="تصویر">
                            {% if message.content %}
                                <div class="message-content">
                                    {{ message.content }}
                                </div>
                            {% endif %}
                            <div class="file-info">{{ message.file_name }}</div>
                        </div>
                    {% elif message.message_type == 'file' %}
                        <div class="message-file">
                            <a href="{{ message.file.url }}" target="_blank" class="file-link">
                                <i class="fas fa-file"></i>
                                {% if message.content %}
                                    <div class="message-content">
                                        {{ message.content }}
                                    </div>
                                {% endif %}
                                <div class="file-info">
                                    {{ message.file_name }} ({{ message.file_size|filesizeformat }})
                                </div>
                            </a>
                        </div>
                    {% else %}
                        <div class="message-content">
                            {{ message.content }}
                        </div>
                    {% endif %}
                    <div class="message-meta">
                        <span class="message-time">{{ message.created_at|date:"H:i" }}</span>
                        {% if message.sender == request.user %}
                            {% if message.is_read %}
                                <span class="read-status read"><i class="fas fa-check-double"></i></span>
                            {% else %}
                                <span class="read-status unread"><i class="fas fa-check"></i></span>
                            {% endif %}
                        {% endif %}
                    </div>
                </div>
            {% endif %}
        {% endfor %}
    </div>

    {% if not room.is_closed_by_admin and not room.is_closed_by_user %}
        <div class="chat-input-container" id="chat-input-container">
            <form id="chat-form" class="chat-form">
                <div class="file-preview" id="file-preview"></div>
                <div class="input-group">
                    <input type="text" id="chat-input" class="form-control" placeholder="پیام خود را بنویسید...">
                    <div class="input-group-append">
                        <button type="button" id="file-btn" class="btn btn-outline-secondary">
                            <i class="fas fa-paperclip"></i>
                        </button>
                        <input type="file" id="file-input" style="display: none;">
                        <button type="submit" class="btn btn-primary">ارسال</button>
                    </div>
                </div>
            </form>
        </div>
    {% elif room.is_closed_by_admin %}
        <div class="alert alert-danger chat-closed-alert">
            این گفتگو توسط پشتیبانی بسته شده است و امکان ارسال پیام جدید وجود ندارد.
        </div>
    {% elif room.is_closed_by_user and user.is_staff %}
        <div class="alert alert-warning chat-closed-alert">
            این گفتگو توسط کاربر بسته شده است و امکان ارسال پیام جدید وجود ندارد.
        </div>
    {% elif room.is_closed_by_user %}
        <div class="alert alert-warning chat-closed-alert">
            این گفتگو توسط شما بسته شده است و امکان ارسال پیام جدید وجود ندارد.
        </div>
    {% endif %}
</div>
{% endblock %}

{% block extra_js %}
<script>
    const roomId = "{{ room.id }}";
    const currentUserId = "{{ request.user.id }}";
    const isStaff = {% if user.is_staff %}true{% else %}false{% endif %};
    const isClosed = {% if room.is_closed_by_admin or room.is_closed_by_user %}true{% else %}false{% endif %};

    // WebSocket URL
    const chatSocket = new WebSocket(
        (window.location.protocol === 'https:' ? 'wss://' : 'ws://') +
        window.location.host +
        '/ws/chat/' + roomId + '/'
    );

    const chatMessages = document.getElementById('chat-messages');
    const chatForm = document.getElementById('chat-form');
    const chatInput = document.getElementById('chat-input');
    const fileInput = document.getElementById('file-input');
    const fileBtn = document.getElementById('file-btn');
    const filePreview = document.getElementById('file-preview');
    const closeBtn = document.getElementById('close-chat-btn');
    const chatStatus = document.getElementById('chat-status');

    let selectedFile = null;

    // Auto-scroll to bottom
    function scrollToBottom() {
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Scroll to bottom on page load
    scrollToBottom();

    // WebSocket event handlers
    chatSocket.onopen = function(e) {
        console.log('WebSocket connection established');
    };

    chatSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);
        console.log('WebSocket message received:', data);

        if (data.type === 'chat_message' || data.type === 'message') {
            // Handle new message
            appendMessage(data);
            scrollToBottom();
        } else if (data.type === 'user_status_update' || data.type === 'user_status') {
            // Update user status indicator
            updateUserStatus(data.status);
        } else if (data.type === 'chat_closed' || data.type === 'chat_status_update') {
            // Handle chat closure
            handleChatClosure(data);
        } else if (data.type === 'error') {
            // Show error message
            showError(data.message);
        } else if (data.type === 'message_read') {
            // Update read status for message
            updateReadStatus(data.message_id);
        }
    };

    chatSocket.onclose = function(e) {
        console.log('WebSocket connection closed');
    };

    chatSocket.onerror = function(e) {
        console.error('WebSocket error:', e);
    };

    // Submit chat form
    if (chatForm) {
        chatForm.addEventListener('submit', function(e) {
            e.preventDefault();

            const message = chatInput.value.trim();

            if (!message && !selectedFile) {
                return;
            }

            if (selectedFile) {
                // Send file with optional message
                sendFileMessage(selectedFile, message);
            } else {
                // Send text message
                sendTextMessage(message);
            }

            // Clear input
            chatInput.value = '';
            clearFilePreview();
        });
    }

    // File input handling
    if (fileBtn) {
        fileBtn.addEventListener('click', function() {
            fileInput.click();
        });
    }

    if (fileInput) {
        fileInput.addEventListener('change', function() {
            if (fileInput.files && fileInput.files[0]) {
                selectedFile = fileInput.files[0];
                showFilePreview(selectedFile);
            }
        });
    }

    // Close chat button
    if (closeBtn) {
        closeBtn.addEventListener('click', function() {
            if (confirm('آیا از بستن این گفتگو اطمینان دارید؟')) {
                if (isStaff) {
                    // Admin closing the chat
                    fetch('{% url "chat:admin_close_chat" room.id %}', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': getCookie('csrftoken'),
                            'Content-Type': 'application/json'
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            window.location.reload();
                        } else {
                            showError(data.error || 'خطا در بستن گفتگو');
                        }
                    });
                } else {
                    // User closing the chat
                    fetch('{% url "chat:user_close_chat" room.id %}', {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': getCookie('csrftoken'),
                            'Content-Type': 'application/json'
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            window.location.reload();
                        } else {
                            showError(data.error || 'خطا در بستن گفتگو');
                        }
                    });
                }
            }
        });
    }

    // Show file preview
    function showFilePreview(file) {
        filePreview.innerHTML = '';

        const previewContainer = document.createElement('div');
        previewContainer.className = 'file-preview-item';

        const fileInfo = document.createElement('div');
        fileInfo.className = 'file-info';
        fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-file-btn';
        removeBtn.innerHTML = '&times;';
        removeBtn.addEventListener('click', clearFilePreview);

        previewContainer.appendChild(fileInfo);
        previewContainer.appendChild(removeBtn);

        // If it's an image, show preview
        if (file.type.startsWith('image/')) {
            const img = document.createElement('img');
            img.className = 'image-preview';
            img.file = file;

            const reader = new FileReader();
            reader.onload = (function(aImg) {
                return function(e) {
                    aImg.src = e.target.result;
                };
            })(img);

            reader.readAsDataURL(file);
            previewContainer.insertBefore(img, fileInfo);
        } else {
            // For non-image files
            const fileIcon = document.createElement('div');
            fileIcon.className = 'file-icon';
            fileIcon.innerHTML = '<i class="fas fa-file"></i>';
            previewContainer.insertBefore(fileIcon, fileInfo);
        }

        filePreview.appendChild(previewContainer);
        filePreview.style.display = 'block';
    }

    // Clear file preview
    function clearFilePreview() {
        filePreview.innerHTML = '';
        filePreview.style.display = 'none';
        selectedFile = null;
        if (fileInput) {
            fileInput.value = '';
        }
    }

    // Format file size
    function formatFileSize(bytes) {
        if (bytes < 1024) {
            return bytes + ' B';
        } else if (bytes < 1024 * 1024) {
            return (bytes / 1024).toFixed(1) + ' KB';
        } else {
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
    }

    // Send text message
    function sendTextMessage(message) {
        chatSocket.send(JSON.stringify({
            'type': 'chat_message',
            'message': message
        }));
    }

    // Send file with optional message
    function sendFileMessage(file, message) {
        const reader = new FileReader();
        reader.onload = function(e) {
            chatSocket.send(JSON.stringify({
                'type': 'chat_message',
                'message': message,
                'file': {
                    'content': e.target.result,
                    'info': {
                        'name': file.name,
                        'type': file.type,
                        'size': file.size
                    }
                }
            }));
        };
        reader.readAsDataURL(file);
    }

    // Append new message to chat
    function appendMessage(data) {
        const messageDiv = document.createElement('div');
        messageDiv.id = 'msg-' + data.message_id;

        if (data.message_type === 'system') {
            messageDiv.className = 'message system-message';
            messageDiv.innerHTML = `
                <div class="message-content">${data.message}</div>
            `;
        } else {
            const isCurrentUser = data.sender_id === currentUserId || data.user_id === currentUserId;
            messageDiv.className = `message ${isCurrentUser ? 'sent' : 'received'}`;

            let messageContent = '';

            if (data.message_type === 'image') {
                messageContent = `
                    <div class="message-file image-file">
                        <img src="${data.file_url}" alt="تصویر">
                        ${data.message ? `<div class="message-content">${data.message}</div>` : ''}
                        <div class="file-info">${data.file_name}</div>
                    </div>
                `;
            } else if (data.message_type === 'file') {
                messageContent = `
                    <div class="message-file">
                        <a href="${data.file_url}" target="_blank" class="file-link">
                            <i class="fas fa-file"></i>
                            ${data.message ? `<div class="message-content">${data.message}</div>` : ''}
                            <div class="file-info">
                                ${data.file_name} (${formatFileSize(data.file_size)})
                            </div>
                        </a>
                    </div>
                `;
            } else {
                messageContent = `<div class="message-content">${data.message}</div>`;
            }

            messageDiv.innerHTML = `
                ${messageContent}
                <div class="message-meta">
                    <span class="message-time">${formatTime(data.timestamp)}</span>
                    ${isCurrentUser ? '<span class="read-status unread"><i class="fas fa-check"></i></span>' : ''}
                </div>
            `;
        }

        chatMessages.appendChild(messageDiv);
    }

    // Format timestamp to HH:MM
    function formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.getHours().toString().padStart(2, '0') + ':' +
               date.getMinutes().toString().padStart(2, '0');
    }

    // Update user status indicator
    function updateUserStatus(status) {
        const statusIndicator = chatStatus.querySelector('.status-indicator');

        if (status === 'online') {
            statusIndicator.classList.remove('offline');
            statusIndicator.classList.add('online');
            chatStatus.innerHTML = '<span class="status-indicator online"></span> آنلاین';
        } else {
            statusIndicator.classList.remove('online');
            statusIndicator.classList.add('offline');
            chatStatus.innerHTML = '<span class="status-indicator offline"></span> آفلاین';
        }
    }

    // Handle chat closure
    function handleChatClosure(data) {
        // Reload page to show closure state
        window.location.reload();
    }

    // Update read status for message
    function updateReadStatus(messageId) {
        const messageElement = document.getElementById('msg-' + messageId);
        if (messageElement) {
            const readStatus = messageElement.querySelector('.read-status');
            if (readStatus) {
                readStatus.classList.remove('unread');
                readStatus.classList.add('read');
                readStatus.innerHTML = '<i class="fas fa-check-double"></i>';
            }
        }
    }

    // Show error message
    function showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'alert alert-danger';
        errorDiv.textContent = message;

        const container = document.querySelector('.chat-container');
        container.insertBefore(errorDiv, chatMessages);

        // Remove after 5 seconds
        setTimeout(() => {
            errorDiv.remove();
        }, 5000);
    }

    // Send heartbeat every 30 seconds to keep connection alive and update online status
    setInterval(function() {
        if (chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({
                'type': 'heartbeat'
            }));
        }
    }, 30000);

    // Handle page unload - mark user as offline if they navigate away
    window.addEventListener('beforeunload', function() {
        if (chatSocket.readyState === WebSocket.OPEN) {
            // This is a synchronous call that might not always complete before the page unloads
            // But it's worth trying
            chatSocket.send(JSON.stringify({
                'type': 'offline'
            }));
        }
    });

    // Get CSRF token from cookies
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
</script>
{% endblock %}

====== FILE: templates/chat/start_chat.html ======

{% extends "base/base.html" %}
{% load static %}

{% block title %}شروع چت جدید{% endblock %}

{% block content %}
<div class="container">
    <div class="row justify-content-center">
        <div class="col-md-8 col-lg-6">
            <div class="card shadow-sm">
                <div class="card-body text-center p-5">
                    <h1 class="mb-4">شروع گفتگو با پشتیبانی</h1>

                    <p class="lead mb-4">برای شروع گفتگو با پشتیبانی زیما، لطفاً روی دکمه زیر کلیک کنید.</p>

                    <p class="text-muted mb-5">کارشناسان ما آماده پاسخگویی به سوالات شما هستند.</p>

                    <form method="post" action="{% url 'chat:start_chat' %}">
                        {% csrf_token %}
                        <button type="submit" class="btn btn-primary btn-lg">شروع گفتگو</button>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

====== FILE: templates/chat/chat_list.html ======

{% extends "base/base.html" %}
{% load static %}

{% block title %}گفتگوهای من{% endblock %}

{% block extra_css %}
<style>
    .chat-list-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
    }

    .chat-list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
    }

    .chat-list-header h1 {
        margin: 0;
        color: #333;
    }

    .chat-item {
        background-color: #fff;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        padding: 20px;
        position: relative;
        transition: transform 0.2s ease;
    }

    .chat-item:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .chat-item.closed {
        background-color: #f8f9fa;
    }

    .chat-info {
        margin-bottom: 15px;
    }

    .chat-info h3 {
        margin: 0 0 10px 0;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .chat-info p {
        color: #6c757d;
        margin: 0;
        font-size: 14px;
    }

    .chat-actions {
        display: flex;
        justify-content: flex-end;
    }

    .unread-badge {
        position: absolute;
        top: 20px;
        right: 20px;
    }

    .unread-badge .badge {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        font-size: 12px;
    }

    .badge {
        padding: 5px 10px;
        border-radius: 50px;
        font-size: 12px;
        font-weight: normal;
    }

    .badge-success {
        background-color: #28a745;
        color: white;
    }

    .badge-warning {
        background-color: #ffc107;
        color: #212529;
    }

    .badge-danger {
        background-color: #dc3545;
        color: white;
    }

    .empty-state {
        text-align: center;
        padding: 50px 20px;
        background-color: #f8f9fa;
        border-radius: 10px;
        margin-top: 30px;
    }

    .empty-state p {
        color: #6c757d;
        margin-bottom: 20px;
    }

    .btn-primary {
        background-color: #007bff;
        border-color: #007bff;
    }

    .btn-primary:hover {
        background-color: #0069d9;
        border-color: #0062cc;
    }

    .btn-lg {
        padding: 10px 20px;
        font-size: 16px;
    }

    /* اضافه کردن آیکون به عنوان نشانگر وضعیت */
    .chat-status-icon {
        margin-left: 8px;
        font-size: 14px;
    }

    .active-icon {
        color: #28a745;
    }

    .closed-user-icon {
        color: #ffc107;
    }

    .closed-admin-icon {
        color: #dc3545;
    }

    /* نمایش آخرین پیام */
    .chat-last-message {
        background-color: #f8f9fa;
        padding: 10px 15px;
        border-radius: 8px;
        margin: 10px 0;
        font-size: 14px;
        color: #495057;
        position: relative;
        max-height: 60px;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .chat-last-message::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 20px;
        background: linear-gradient(to bottom, rgba(248, 249, 250, 0), rgba(248, 249, 250, 1));
    }

    /* نشانگر آنلاین بودن */
    .online-status {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-left: 5px;
    }

    .online {
        background-color: #28a745;
    }

    .offline {
        background-color: #dc3545;
    }
</style>
{% endblock %}

{% block content %}
<div class="chat-list-container">
    <div class="chat-list-header">
        <h1>گفتگوهای من</h1>
        <a href="{% url 'chat:start_chat' %}" class="btn btn-primary">گفتگوی جدید</a>
    </div>

    <div class="chat-list">
        {% if user_chats %}
            {% for chat in user_chats %}
                <div class="chat-item {% if chat.is_closed_by_admin or chat.is_closed_by_user %}closed{% endif %}">
                    <div class="chat-info">
                        <h3>
                            <span>
                                {% if chat.admin %}
                                    گفتگو با {{ chat.admin.get_full_name|default:chat.admin.username }}
                                {% else %}
                                    گفتگو با پشتیبانی
                                {% endif %}

                                {% if not chat.is_closed_by_admin and not chat.is_closed_by_user %}
                                    <span class="chat-status-icon active-icon">
                                        <i class="fas fa-comment-dots"></i>
                                        <span class="badge badge-success">فعال</span>
                                    </span>
                                {% elif chat.is_closed_by_user %}
                                    <span class="chat-status-icon closed-user-icon">
                                        <i class="fas fa-comment-slash"></i>
                                        <span class="badge badge-warning">بسته شده توسط شما</span>
                                    </span>
                                {% elif chat.is_closed_by_admin %}
                                    <span class="chat-status-icon closed-admin-icon">
                                        <i class="fas fa-comment-slash"></i>
                                        <span class="badge badge-danger">بسته شده توسط پشتیبانی</span>
                                    </span>
                                {% endif %}

                                {% if chat.admin_online %}
                                    <span class="online-status online" title="پشتیبان آنلاین است"></span>
                                {% else %}
                                    <span class="online-status offline" title="پشتیبان آفلاین است"></span>
                                {% endif %}
                            </span>
                        </h3>
                        <p>آخرین بروزرسانی: {{ chat.updated_at|date:"Y/m/d H:i" }}</p>
                    </div>

                    {% if chat.last_message %}
                        <div class="chat-last-message">
                            {% if chat.last_message.sender == request.user %}
                                <strong>شما: </strong>
                            {% elif chat.last_message.sender %}
                                <strong>{{ chat.last_message.sender.get_full_name|default:chat.last_message.sender.username }}: </strong>
                            {% else %}
                                <strong>سیستم: </strong>
                            {% endif %}
                            {{ chat.last_message.content|truncatechars:100 }}
                        </div>
                    {% endif %}

                    {% if chat.unread_count > 0 %}
                        <div class="unread-badge">
                            <span class="badge badge-danger">{{ chat.unread_count }}</span>
                        </div>
                    {% endif %}

                    <div class="chat-actions">
                        <a href="{% url 'chat:chat_room' chat.id %}" class="btn btn-primary">مشاهده</a>
                    </div>
                </div>
            {% endfor %}
        {% else %}
            <div class="empty-state">
                <i class="fas fa-comments fa-3x mb-3 text-muted"></i>
                <p>هیچ گفتگویی ندارید</p>
                <p>برای شروع گفتگو با پشتیبانی، روی دکمه گفتگوی جدید کلیک کنید.</p>
                <a href="{% url 'chat:start_chat' %}" class="btn btn-primary btn-lg">شروع گفتگوی جدید</a>
            </div>
        {% endif %}
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // اتصال به وب‌سوکت برای دریافت اعلان‌های جدید
    const notificationSocket = new WebSocket(
        (window.location.protocol === 'https:' ? 'wss://' : 'ws://') +
        window.location.host +
        '/ws/notifications/'
    );

    notificationSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);

        // اگر اعلان جدید مربوط به چت دریافت کردیم، صفحه را رفرش کنیم
        if (data.type === 'notification' && data.notification_type === 'chat') {
            window.location.reload();
        }
    };

    // برای جلوگیری از قطع شدن اتصال، هر 30 ثانیه یک پیام heartbeat ارسال می‌کنیم
    setInterval(function() {
        if (notificationSocket.readyState === WebSocket.OPEN) {
            notificationSocket.send(JSON.stringify({
                'type': 'heartbeat'
            }));
        }
    }, 30000);
</script>
{% endblock %}

====== FILE: templates/chat/notifications.html ======

{% extends "base/base.html" %}
{% load static %}

{% block title %}اعلان‌های من{% endblock %}

{% block extra_css %}
<style>
    .notifications-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
    }

    .notification-item {
        background-color: #fff;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
        position: relative;
    }

    .notification-item:hover {
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        transform: translateY(-2px);
    }

    .notification-unread {
        border-right: 4px solid #007bff;
    }

    .notification-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .notification-title {
        font-weight: bold;
        font-size: 1.1rem;
    }

    .notification-time {
        color: #777;
        font-size: 0.8rem;
    }

    .notification-content {
        color: #555;
    }

    .notification-type {
        display: inline-block;
        padding: 3px 10px;
        border-radius: 15px;
        font-size: 0.8rem;
        margin-right: 10px;
    }

    .notification-type-chat {
        background-color: #d4edda;
        color: #155724;
    }

    .notification-type-order {
        background-color: #cce5ff;
        color: #004085;
    }

    .notification-type-product {
        background-color: #fff3cd;
        color: #856404;
    }

    .notification-type-system {
        background-color: #f8d7da;
        color: #721c24;
    }

    .notification-mark-read {
        position: absolute;
        top: 15px;
        left: 15px;
        color: #6c757d;
        cursor: pointer;
        transition: color 0.3s ease;
    }

    .notification-mark-read:hover {
        color: #007bff;
    }

    .empty-state {
        text-align: center;
        padding: 40px 20px;
        background-color: #f9f9f9;
        border-radius: 10px;
        color: #666;
    }

    .empty-state i {
        font-size: 3rem;
        margin-bottom: 15px;
        color: #ccc;
    }
</style>
{% endblock %}

{% block content %}
<div class="notifications-container">
    <h1>اعلان‌های من</h1>

    <div class="notifications-list">
        {% if notifications %}
            {% for notification in notifications %}
                <div class="notification-item {% if not notification.is_read %}unread{% endif %}">
                    <div class="notification-header">
                        <h3 class="notification-title">
                            {{ notification.title }}
                            <span class="notification-type">
                                {% if notification.notification_type == 'chat' %}
                                    پیام چت
                                {% elif notification.notification_type == 'order' %}
                                    سفارش
                                {% elif notification.notification_type == 'product' %}
                                    محصول
                                {% else %}
                                    سیستم
                                {% endif %}
                            </span>
                        </h3>
                        <span class="notification-time">{{ notification.created_at|date:"Y/m/d H:i" }}</span>
                    </div>

                    <div class="notification-content">
                        {{ notification.message }}
                    </div>

                    {% if not notification.is_read %}
                        <button class="btn btn-sm btn-outline-primary mark-read" data-id="{{ notification.id }}">
                            علامت خوانده شده
                        </button>
                    {% endif %}
                </div>
            {% endfor %}
        {% else %}
            <div class="empty-state">
                <p>هیچ اعلانی ندارید</p>
                <p>اعلان‌های جدید در اینجا نمایش داده می‌شوند.</p>
            </div>
        {% endif %}
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
    // Connect to notification WebSocket
    const notificationSocket = new WebSocket(
        'ws://' + window.location.host + '/ws/notifications/'
    );

    notificationSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);
        if (data.type === 'notification') {
            // Add new notification to the list
            addNewNotification(data);
        }
    };

    // Mark notification as read
    document.querySelectorAll('.mark-read').forEach(button => {
        button.addEventListener('click', function() {
            const notificationId = this.dataset.id;

            // Send WebSocket message
            notificationSocket.send(JSON.stringify({
                'action': 'mark_read',
                'notification_id': notificationId
            }));

            // Update UI
            this.closest('.notification-item').classList.remove('unread');
            this.remove();
        });
    });

    function addNewNotification(data) {
        // Create new notification element
        const notificationsList = document.querySelector('.notifications-list');
        const emptyState = document.querySelector('.empty-state');

        if (emptyState) {
            emptyState.remove();
        }

        const notificationItem = document.createElement('div');
        notificationItem.className = 'notification-item unread';

        // Add notification content
        notificationItem.innerHTML = `
            <div class="notification-header">
                <h3 class="notification-title">
                    ${data.title}
                    <span class="notification-type">
                        ${getNotificationType(data.notification_type)}
                    </span>
                </h3>
                <span class="notification-time">${formatDateTime(data.timestamp)}</span>
            </div>

            <div class="notification-content">
                ${data.message}
            </div>

            <button class="btn btn-sm btn-outline-primary mark-read" data-id="${data.id}">
                علامت خوانده شده
            </button>
        `;

        // Add to the beginning of the list
        notificationsList.insertBefore(notificationItem, notificationsList.firstChild);

        // Add click event listener to the new button
        notificationItem.querySelector('.mark-read').addEventListener('click', function() {
            const notificationId = this.dataset.id;

            // Send WebSocket message
            notificationSocket.send(JSON.stringify({
                'action': 'mark_read',
                'notification_id': notificationId
            }));

            // Update UI
            this.closest('.notification-item').classList.remove('unread');
            this.remove();
        });
    }

    function getNotificationType(type) {
        switch(type) {
            case 'chat': return 'پیام چت';
            case 'order': return 'سفارش';
            case 'product': return 'محصول';
            default: return 'سیستم';
        }
    }

    function formatDateTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleDateString('fa-IR') + ' ' + date.toLocaleTimeString('fa-IR', {hour: '2-digit', minute:'2-digit'});
    }
</script>
{% endblock %}

====== FILE: templates/chat/partials/pending_chats.html ======

{% if pending_rooms %}
    {% for room in pending_rooms %}
        <div class="chat-item">
            <div class="chat-header">
                <span class="chat-title">{{ room.name|default:"گفتگو" }} در انتظار</span>
                <span class="chat-time">{{ room.created_at|date:"Y/m/d H:i" }}</span>
            </div>
            <div class="chat-user">
                {% if room.user %}
                    {{ room.user.get_full_name|default:room.user.username }}
                {% else %}
                    کاربر ناشناس
                {% endif %}
            </div>
            {% if room.messages.last %}
                <div class="chat-preview">
                    {{ room.messages.last.content|truncatechars:50 }}
                </div>
            {% endif %}
            <div class="chat-actions">
                <a href="{% url 'chat:chat_room' room.name %}" class="btn btn-primary">پاسخ</a>
            </div>
        </div>
    {% endfor %}
{% else %}
    <div class="empty-state">
        چت در انتظاری وجود ندارد.
    </div>
{% endif %}

====== FILE: templates/chat/partials/active_chats.html ======

{% if admin_active_chats %}
    {% for room in admin_active_chats %}
        <div class="chat-item">
            <div class="chat-header">
                <span class="chat-title">{{ room.name|default:"گفتگو" }} فعال</span>
                {% if room.unread_count > 0 %}
                    <span class="badge bg-danger">{{ room.unread_count }}</span>
                {% endif %}
                <span class="chat-time">{{ room.updated_at|date:"Y/m/d H:i" }}</span>
            </div>
            <div class="chat-user">
                {% if room.user %}
                    {{ room.user.get_full_name|default:room.user.username }}
                {% else %}
                    کاربر ناشناس
                {% endif %}
            </div>
            {% if room.messages.last %}
                <div class="chat-preview">
                    {{ room.messages.last.content|truncatechars:50 }}
                </div>
            {% endif %}
            <div class="chat-actions">
                <a href="{% url 'chat:chat_room' room.name %}" class="btn btn-primary">ادامه چت</a>
            </div>
        </div>
    {% endfor %}
{% else %}
    <div class="empty-state">
        شما هیچ چت فعالی ندارید.
    </div>
{% endif %}

====== FILE: templates/chat/partials/user_closed_chats.html ======

{% if user_closed_chats %}
    {% for room in user_closed_chats %}
        <div class="chat-item">
            <div class="chat-header">
                <span class="chat-title">{{ room.name|default:"گفتگو" }} بسته شده توسط کاربر</span>
                <span class="chat-time">{{ room.updated_at|date:"Y/m/d H:i" }}</span>
            </div>
            <div class="chat-user">
                {% if room.user %}
                    {{ room.user.get_full_name|default:room.user.username }}
                {% else %}
                    کاربر ناشناس
                {% endif %}
            </div>
            {% if room.closed_at %}
                <div class="chat-closed-time">
                    بسته شده در: {{ room.closed_at|date:"Y/m/d H:i" }}
                </div>
            {% endif %}
            {% if room.messages.last %}
                <div class="chat-preview">
                    {{ room.messages.last.content|truncatechars:50 }}
                </div>
            {% endif %}
            <div class="chat-actions">
                <a href="{% url 'chat:chat_room' room.name %}" class="btn btn-secondary">مشاهده</a>
            </div>
        </div>
    {% endfor %}
{% else %}
    <div class="empty-state">
        چت بسته شده‌ای توسط کاربران وجود ندارد.
    </div>
{% endif %}

====== FILE: templates/base/base.html ======

<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    {% load static %}
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}فروشگاه زیما{% endblock %}</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.rtl.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* استایل برای آیکون سبد خرید */
        .cart-icon {
            position: relative;
            display: inline-block;
            margin-right: 15px;
            color: white;
            font-size: 1.2rem;
            text-decoration: none;
        }

        .cart-count {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #dc3545;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cart-icon:hover {
            color: #f8f9fa;
        }

        /* استایل برای دکمه چت */
        .floating-chat-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .floating-chat-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,123,255,0.4);
        }

        /* استایل برای نشانگر تعداد پیام‌های خوانده نشده روی دکمه چت */
        .floating-chat-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .notification-badge {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
        }

        /* استایل برای اعلان‌ها */
        .notification-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            width: 300px;
        }

        .notification {
            background-color: white;
            border-right: 4px solid #007bff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            animation: slideIn 0.3s ease-out;
            display: flex;
            flex-direction: column;
        }

        .notification-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .notification-title {
            font-weight: bold;
            color: #333;
        }

        .notification-close {
            cursor: pointer;
            color: #999;
        }

        .notification-message {
            color: #666;
        }

        .notification-action {
            margin-top: 10px;
            text-align: left;
        }

        .notification-action a {
            color: #007bff;
            text-decoration: none;
            font-size: 0.9em;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        /* استایل برای اعلان‌های چت */
        .chat-notification {
            position: fixed;
            bottom: 90px;
            left: 20px;
            width: 300px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 15px;
            z-index: 1000;
            transform: translateY(20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .chat-notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .chat-notification-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .chat-notification-body {
            margin-bottom: 10px;
            color: #555;
        }

        .chat-notification-footer {
            text-align: right;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #999;
        }

        .view-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }

        .view-btn:hover {
            background-color: #0056b3;
        }
    </style>
    {% block extra_css %}{% endblock %}
</head>
<body>
    <header class="bg-dark text-white py-3">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-3">
                    <h1 class="h4 mb-0"><a href="/" class="text-white text-decoration-none">فروشگاه زیما</a></h1>
                </div>
                <div class="col-md-6">
                    <form class="d-flex" action="{% url 'products:search' %}" method="GET">
                    <input class="form-control me-2" type="search" name="q" placeholder="جستجو..." aria-label="Search" value="{{ request.GET.q|default:'' }}">
                    <button class="btn btn-outline-light" type="submit">جستجو</button>
                    </form>
                </div>
                <div class="col-md-3 text-end d-flex align-items-center justify-content-end">
                    <!-- آیکون سبد خرید -->
                    <a href="{% url 'cart:summary' %}" class="cart-icon me-3">
                        <i class="fas fa-shopping-cart"></i>
                        <span class="cart-count" id="cart-items-count">
                            {% if user.is_authenticated %}
                                {{ user.cart_items.count }}
                            {% else %}
                                0
                            {% endif %}
                        </span>
                    </a>

                    <!-- آیکون نوتیفیکیشن -->
                    {% if user.is_authenticated %}
                    <a href="{% url 'chat:notifications' %}" class="cart-icon me-3">
                        <i class="fas fa-bell"></i>
                        <span class="cart-count" id="notification-count" style="display: none;">0</span>
                    </a>
                    {% endif %}

                    {% if user.is_authenticated %}
                        <div class="dropdown">
                            <button class="btn btn-outline-light dropdown-toggle" type="button" id="userDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                {{ user.username }}
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="userDropdown">
                                <li><a class="dropdown-item" href="{% url 'users:profile' %}">پروفایل</a></li>
                                <li><a class="dropdown-item" href="#">سفارشات من</a></li>
                                <li><a class="dropdown-item" href="{% url 'chat:chat_list' %}">
                                    <i class="fas fa-comments"></i> چت‌های من
                                    <span class="badge bg-danger notification-badge" id="chat-notification-badge" style="display: none;">0</span>
                                </a></li>
                                {% if user.is_staff %}
                                    <li><a class="dropdown-item" href="{% url 'admin:index' %}">پنل مدیریت</a></li>
                                    <li><a class="dropdown-item" href="{% url 'chat:admin_dashboard' %}">داشبورد چت</a></li>
                                {% endif %}
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="{% url 'users:logout' %}">خروج</a></li>
                            </ul>
                        </div>
                    {% else %}
                        <a href="{% url 'users:login' %}" class="btn btn-outline-light me-2">ورود</a>
                        <a href="{% url 'users:signup' %}" class="btn btn-light">ثبت‌نام</a>
                    {% endif %}
                </div>
            </div>
        </div>
    </header>

    <main class="container my-4">
        {% load i18n %}
        {% if messages %}
        <div class="django-messages">
            {% for message in messages %}
            <div class="alert alert-{{ message.tags }}">
                {{ message }}
            </div>
            {% endfor %}
        </div>
        {% endif %}

        {% block content %}{% endblock %}
    </main>

    <footer class="bg-dark text-white py-4 mt-5">
        <div class="container">
            <div class="row">
                <div class="col-md-4">
                    <h5>فروشگاه زیما</h5>
                    <p>فروشگاه آنلاین محصولات با کیفیت</p>
                </div>
                <div class="col-md-4">
                    <h5>لینک‌های مفید</h5>
                    <ul class="list-unstyled">
                        <li><a href="#" class="text-white">درباره ما</a></li>
                        <li><a href="#" class="text-white">تماس با ما</a></li>
                        <li><a href="#" class="text-white">قوانین و مقررات</a></li>
                    </ul>
                </div>
                <div class="col-md-4">
                    <h5>تماس با ما</h5>
                    <address>
                        <p>آدرس: تهران، خیابان ولیعصر</p>
                        <p>تلفن: 021-12345678</p>
                        <p>ایمیل: info@zima.com</p>
                    </address>
                </div>
            </div>
            <hr>
            <div class="text-center">
                <p>&copy; 1404 فروشگاه زیما. تمامی حقوق محفوظ است.</p>
            </div>
        </div>
    </footer>

    <!-- دکمه چت پشتیبانی - تغییر مسیر بر اساس نوع کاربر -->
    {% if user.is_authenticated %}
    <div class="floating-chat-btn" id="floating-chat-btn" title="{% if user.is_staff %}داشبورد چت{% else %}چت‌های من{% endif %}">
        <i class="fas {% if user.is_staff %}fa-headset{% else %}fa-comments{% endif %} fa-lg"></i>
        <span class="floating-chat-badge" id="unread-count" style="display: none;">0</span>
    </div>

    <!-- کانتینر اعلان‌ها -->
    <div id="notification-container" class="notification-container"></div>

    <!-- صدای اعلان -->
    <audio id="notification-sound" preload="auto" style="display: none;">
        <source src="{% static 'sounds/notification.mp3' %}" type="audio/mpeg">
    </audio>
    {% endif %}

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    {% if user.is_authenticated %}
    <script>
        // تنظیم متغیر برای تشخیص اینکه کاربر احراز هویت شده است
        const userIsAuthenticated = true;

        // سوکت اعلان و سوکت وضعیت آنلاین
        let notificationSocket = null;
        let onlineStatusSocket = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        // تابع اتصال به سوکت اعلان‌ها
        function connectNotificationSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws/notifications/`;

            notificationSocket = new WebSocket(wsUrl);

            notificationSocket.onopen = function(e) {
                console.log('Notification socket connected');
                reconnectAttempts = 0; // بازنشانی تعداد تلاش‌ها پس از اتصال موفق
                // شروع ارسال منظم سیگنال heartbeat
                startHeartbeat();
            };

            notificationSocket.onmessage = function(e) {
                const data = JSON.parse(e.data);

                if (data.type === 'unread_count') {
                    handleUnreadCountUpdate(data.count);
                } else if (data.type === 'chat_notification') {
                    handleChatNotification(data);
                } else if (data.type === 'user_status_update') {
                    updateUserStatus(data.user_id, data.status);
                } else if (data.type === 'heartbeat_response') {
                    // سرور پاسخ heartbeat را دریافت کرده است
                    console.log('Heartbeat acknowledged by server');
                }
            };

            notificationSocket.onclose = function(e) {
                console.log('Notification socket closed');

                // تلاش مجدد برای اتصال با فاصله زمانی بیشتر در هر بار تلاش
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                    reconnectAttempts++;

                    console.log(`Reconnecting in ${delay/1000} seconds... (Attempt ${reconnectAttempts})`);

                    setTimeout(function() {
                        connectNotificationSocket();
                    }, delay);
                } else {
                    console.log('Maximum reconnection attempts reached. Using fallback HTTP method.');
                    // استفاده از روش HTTP به عنوان پشتیبان
                    startHttpFallback();
                }
            };

            notificationSocket.onerror = function(e) {
                console.error('Notification socket error:', e);
            };
        }

        // تابع اتصال به سوکت وضعیت آنلاین
        function connectOnlineStatusSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws/online-status/`;

            onlineStatusSocket = new WebSocket(wsUrl);

            onlineStatusSocket.onopen = function(e) {
                console.log('Online status socket connected');

                // ارسال heartbeat هر 30 ثانیه
                setInterval(function() {
                    if (onlineStatusSocket.readyState === WebSocket.OPEN) {
                        onlineStatusSocket.send(JSON.stringify({
                            'type': 'heartbeat'
                        }));
                    }
                }, 30000);
            };

            onlineStatusSocket.onmessage = function(e) {
                const data = JSON.parse(e.data);
                console.log('Online status message received:', data);

                // پردازش پیام‌های دریافتی
                if (data.type === 'status_update') {
                    updateUserStatus(data.user_id, data.status);
                }
            };

            onlineStatusSocket.onclose = function(e) {
                console.log('Online status socket closed');

                // تلاش مجدد برای اتصال
                setTimeout(function() {
                    connectOnlineStatusSocket();
                }, 5000);
            };

            onlineStatusSocket.onerror = function(e) {
                console.error('Online status socket error:', e);
            };

            // تنظیم وضعیت آفلاین هنگام بستن صفحه یا رفرش
            window.addEventListener('beforeunload', function() {
                if (onlineStatusSocket.readyState === WebSocket.OPEN) {
                    // ارسال پیام آفلاین شدن
                    onlineStatusSocket.send(JSON.stringify({
                        'type': 'offline'
                    }));
                }
            });
        }

        // ارسال سیگنال heartbeat هر 30 ثانیه
        let heartbeatInterval = null;
        function startHeartbeat() {
            // توقف هر heartbeat قبلی
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }

            // شروع ارسال heartbeat جدید
            heartbeatInterval = setInterval(function() {
                if (notificationSocket && notificationSocket.readyState === WebSocket.OPEN) {
                    notificationSocket.send(JSON.stringify({
                        'type': 'heartbeat'
                    }));
                }
            }, 30000); // هر 30 ثانیه
        }

        // در صورت عدم موفقیت در اتصال WebSocket، از HTTP استفاده کنیم
        function startHttpFallback() {
            // توقف هر تایمر قبلی
            if (heartbeatInterval) clearInterval(heartbeatInterval);

            // ارسال وضعیت آنلاین با HTTP
            fetch('/chat/set-online/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                }
            }).catch(error => console.error('Error updating online status:', error));

            // تنظیم تایمر جدید با HTTP
            heartbeatInterval = setInterval(function() {
                fetch('/chat/set-online/', {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken'),
                        'Content-Type': 'application/json'
                    }
                }).catch(error => console.error('Error updating online status:', error));

                // همچنین بررسی پیام‌های خوانده نشده
                checkUnreadCounts();
            }, 60000); // هر 60 ثانیه
        }

        // پردازش بروزرسانی تعداد پیام‌های خوانده نشده
        function handleUnreadCountUpdate(count) {
            // بروزرسانی نشانگر روی دکمه شناور چت
            const unreadBadge = document.getElementById('unread-count');
            if (unreadBadge) {
                if (count > 0) {
                    unreadBadge.textContent = count;
                    unreadBadge.style.display = 'flex';
                } else {
                    unreadBadge.style.display = 'none';
                }
            }

            // بروزرسانی نشانگر در منوی کاربر
            const chatNotificationBadge = document.getElementById('chat-notification-badge');
            if (chatNotificationBadge) {
                if (count > 0) {
                    chatNotificationBadge.textContent = count;
                    chatNotificationBadge.style.display = 'inline-block';
                } else {
                    chatNotificationBadge.style.display = 'none';
                }
            }
        }

        // پردازش اعلان چت جدید
        function handleChatNotification(data) {
            // نمایش اعلان به کاربر
            if (Notification.permission === "granted") {
                const notification = new Notification(data.is_admin ? "پیام جدید از پشتیبانی" : `پیام جدید از ${data.sender}`, {
                    body: data.message,
                    icon: '/static/img/logo-small.png'
                });

                notification.onclick = function() {
                    window.focus();
                    window.location.href = `/chat/room/${data.room_id}/`;
                };
            }

            // پخش صدای اعلان
            const audio = document.getElementById('notification-sound');
            if (audio) {
                audio.play().catch(e => console.log('Error playing notification sound:', e));
            }

            // نمایش اعلان در صفحه
            showChatNotification(data.message, data.sender, data.room_id);
        }

        // نمایش اعلان چت در صفحه
        function showChatNotification(message, sender, roomId) {
            const notificationDiv = document.createElement('div');
            notificationDiv.className = 'chat-notification';
            notificationDiv.innerHTML = `
                <div class="chat-notification-header">
                    <strong>پیام جدید از ${sender}</strong>
                    <button class="close-btn">&times;</button>
                </div>
                <div class="chat-notification-body">${message}</div>
                <div class="chat-notification-footer">
                    <button class="view-btn">مشاهده</button>
                </div>
            `;

            document.body.appendChild(notificationDiv);

            // نمایش اعلان با انیمیشن
            setTimeout(() => {
                notificationDiv.classList.add('show');
            }, 100);

            // دکمه بستن اعلان
            notificationDiv.querySelector('.close-btn').addEventListener('click', function() {
                notificationDiv.classList.remove('show');
                setTimeout(() => {
                    notificationDiv.remove();
                }, 300);
            });

            // دکمه مشاهده چت
            notificationDiv.querySelector('.view-btn').addEventListener('click', function() {
                window.location.href = `/chat/room/${roomId}/`;
            });

            // حذف خودکار اعلان بعد از 10 ثانیه
            setTimeout(() => {
                if (notificationDiv.parentNode) {
                    notificationDiv.classList.remove('show');
                    setTimeout(() => {
                        if (notificationDiv.parentNode) {
                            notificationDiv.remove();
                        }
                    }, 300);
                }
            }, 10000);
        }

        // بروزرسانی وضعیت کاربر
        function updateUserStatus(userId, status) {
            // پیدا کردن تمام المان‌های نشان‌دهنده وضعیت کاربر با این شناسه
            const statusIndicators = document.querySelectorAll(`.user-status-indicator[data-user-id="${userId}"]`);

            statusIndicators.forEach(indicator => {
                // حذف کلاس‌های قبلی
                indicator.classList.remove('online', 'offline');

                // اضافه کردن کلاس جدید بر اساس وضعیت
                indicator.classList.add(status);

                // بروزرسانی متن نمایش داده شده (اگر وجود دارد)
                const statusText = indicator.querySelector('.status-text');
                if (statusText) {
                    statusText.textContent = status === 'online' ? 'آنلاین' : 'آفلاین';
                }
            });
        }

        // محدودسازی تعداد درخواست‌ها
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        // ارسال heartbeat محدودشده بر اساس فعالیت کاربر
        const throttledHeartbeat = throttle(function() {
            if (notificationSocket && notificationSocket.readyState === WebSocket.OPEN) {
                notificationSocket.send(JSON.stringify({
                    'type': 'heartbeat'
                }));
            }

            if (onlineStatusSocket && onlineStatusSocket.readyState === WebSocket.OPEN) {
                onlineStatusSocket.send(JSON.stringify({
                    'type': 'heartbeat'
                }));
            }
        }, 5000); // حداکثر هر 5 ثانیه یک بار بر اساس فعالیت کاربر

        // رویدادهای فعالیت کاربر - فقط heartbeat محدودشده را فعال می‌کنند
        ['mousedown', 'keypress', 'scroll', 'touchstart'].forEach(evt => {
            document.addEventListener(evt, throttledHeartbeat);
        });

        // برای mousemove، محدودیت بیشتری اعمال می‌کنیم چون خیلی زیاد فراخوانی می‌شود
        document.addEventListener('mousemove', throttle(function() {
            throttledHeartbeat();
        }, 10000)); // حداکثر هر 10 ثانیه یک بار برای حرکت موس

        // تغییر وضعیت به آفلاین هنگام بستن صفحه
        window.addEventListener('beforeunload', function() {
            // ارسال درخواست برای تغییر وضعیت به آفلاین
            if (notificationSocket && notificationSocket.readyState === WebSocket.OPEN) {
                // ارسال پیام آفلاین شدن از طریق WebSocket
                notificationSocket.send(JSON.stringify({
                    'type': 'offline'
                }));
            }

            if (onlineStatusSocket && onlineStatusSocket.readyState === WebSocket.OPEN) {
                // ارسال پیام آفلاین شدن از طریق WebSocket وضعیت آنلاین
                onlineStatusSocket.send(JSON.stringify({
                    'type': 'offline'
                }));
            } else {
                // استفاده از HTTP fallback
                navigator.sendBeacon('/chat/set-offline/', '');
            }
        });

        // بررسی پیام‌های خوانده نشده با HTTP
        function checkUnreadCounts() {
            fetch('/chat/unread-count/')
                .then(response => response.json())
                .then(data => {
                    handleUnreadCountUpdate(data.count);
                })
                .catch(error => console.error('Error fetching unread count:', error));
        }

        // مجوز برای اعلان‌ها
        function requestNotificationPermission() {
            if (Notification && Notification.permission !== "granted") {
                Notification.requestPermission();
            }
        }

        // دریافت توکن CSRF از کوکی‌ها
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // اجرای توابع در زمان بارگذاری صفحه
        document.addEventListener('DOMContentLoaded', function() {
            // بررسی اولیه پیام‌های خوانده نشده
            checkUnreadCounts();

            // درخواست دسترسی به اعلان‌ها
            requestNotificationPermission();

            // اتصال به WebSocket اعلان‌ها
            try {
                connectNotificationSocket();
            } catch (e) {
                console.error("Error connecting to notification socket:", e);
                // در صورت خطا در اتصال به WebSocket، از روش HTTP استفاده می‌کنیم
                startHttpFallback();
            }

            // اتصال به WebSocket وضعیت آنلاین
            try {
                connectOnlineStatusSocket();
            } catch (e) {
                console.error("Error connecting to online status socket:", e);
            }

            // تنظیم عملکرد دکمه چت شناور بر اساس نوع کاربر
            const chatBtn = document.getElementById('floating-chat-btn');
            if (chatBtn) {
                chatBtn.addEventListener('click', function() {
                    {% if user.is_staff %}
                        // هدایت ادمین به داشبورد چت
                        window.location.href = "{% url 'chat:admin_dashboard' %}";
                    {% else %}
                        // هدایت کاربر عادی به لیست چت‌ها
                        window.location.href = "{% url 'chat:chat_list' %}";
                    {% endif %}
                });
            }
        });
    </script>
    {% endif %}

    {% block extra_js %}{% endblock %}
</body>
</html>

====== FILE: chat/consumers.py ======

from django.contrib.auth import get_user_model
from .models import ChatRoom, ChatMessage, UserChatStatus, Notification
from django.utils import timezone
from channels.db import database_sync_to_async
from django.contrib.auth.models import AnonymousUser

User = get_user_model()
import json
import base64
import uuid
import os
from channels.generic.websocket import AsyncWebsocketConsumer
from django.core.files.base import ContentFile
from django.conf import settings


class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_id = self.scope['url_route']['kwargs']['room_id']
        self.room_group_name = f'chat_{self.room_id}'
        self.user = self.scope['user']

        # بررسی احراز هویت کاربر
        if isinstance(self.user, AnonymousUser) or not self.user.is_authenticated:
            await self.close()
            return

        # اول accept کنید، بعد بقیه کارها
        await self.accept()

        # اضافه کردن کاربر به گروه چت
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )

        # تنظیم وضعیت کاربر به آنلاین
        await self.set_user_status('online')
        room = await self.get_room()

        if not room:
            await self.close()
            return

        # اعلام به همه کاربران در اتاق که این کاربر آنلاین شده
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'user_status_update',
                'user_id': self.user.id,
                'username': self.user.username,
                'status': 'online',
                'is_staff': self.user.is_staff
            }
        )

        # بررسی وضعیت کاربر طرف مقابل
        other_user = await self.get_other_user(room)
        if other_user:
            other_user_status = await self.get_user_status(other_user)
            await self.send(text_data=json.dumps({
                'type': 'user_status_update',
                'user_id': other_user.id,
                'username': other_user.username,
                'status': other_user_status,
                'is_staff': other_user.is_staff
            }))

        # علامت‌گذاری پیام‌های خوانده نشده به عنوان خوانده شده
        await self.mark_messages_as_read()

    async def disconnect(self, close_code):
        # حذف کاربر از گروه چت
        if hasattr(self, 'room_group_name'):
            await self.channel_layer.group_discard(
                self.room_group_name,
                self.channel_name
            )

        # تنظیم وضعیت کاربر به آفلاین فقط اگر کاربر در هیچ سوکت دیگری فعال نباشد
        if hasattr(self, 'user') and self.user.is_authenticated:
            # بررسی اگر این آخرین اتصال کاربر است
            if await self.is_last_connection():
                await self.set_user_status('offline')

                # اعلام به همه کاربران در اتاق که این کاربر آفلاین شده
                await self.channel_layer.group_send(
                    self.room_group_name,
                    {
                        'type': 'user_status_update',
                        'user_id': self.user.id,
                        'username': self.user.username,
                        'status': 'offline',
                        'is_staff': self.user.is_staff
                    }
                )

    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type', 'chat_message')

            if message_type == 'chat_message':
                message = data.get('message', '')
                file_data = data.get('file', None)

                # بررسی وضعیت اتاق
                room = await self.get_room()
                if room and await self.is_chat_closed(room):
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'این گفتگو بسته شده است و امکان ارسال پیام وجود ندارد.'
                    }))
                    return

                try:
                    if file_data:
                        message_obj = await self.save_message_with_file(message, file_data)
                    else:
                        message_obj = await self.save_message(message)

                    # بررسی نوع message_obj و استخراج اطلاعات مورد نیاز
                    if isinstance(message_obj, dict):
                        message_id = message_obj.get('message_id') or message_obj.get('id')
                        timestamp = message_obj.get('timestamp')
                        message_type = message_obj.get('message_type', 'text')
                        file_url = message_obj.get('file_url')
                        file_name = message_obj.get('file_name')
                        file_type = message_obj.get('file_type')
                    else:
                        message_id = str(message_obj.id)
                        timestamp = message_obj.created_at.isoformat()
                        message_type = message_obj.message_type
                        file_url = message_obj.file.url if hasattr(message_obj, 'file') and message_obj.file else None
                        file_name = message_obj.file_name if hasattr(message_obj, 'file_name') else None
                        file_type = message_obj.file_type if hasattr(message_obj, 'file_type') else None

                    # ارسال پیام به گروه چت
                    await self.channel_layer.group_send(
                        self.room_group_name,
                        {
                            'type': 'chat_message',
                            'message': message,
                            'username': self.user.username,
                            'user_id': self.user.id,
                            'message_id': message_id,
                            'timestamp': timestamp,
                            'message_type': message_type,
                            'file_url': file_url,
                            'file_name': file_name,
                            'file_type': file_type,
                            'is_staff': self.user.is_staff,
                        }
                    )

                    # ارسال اعلان به گیرنده
                    receiver = await self.get_receiver()
                    if receiver:
                        notification_group_name = f'notifications_{receiver.id}'

                        # ارسال اعلان برای بروزرسانی تعداد پیام‌های خوانده نشده
                        unread_count = await self.get_user_unread_count(receiver)
                        await self.channel_layer.group_send(
                            notification_group_name,
                            {
                                'type': 'unread_count_update',
                                'count': unread_count
                            }
                        )

                        # برای کاربران عادی، اعلان پاپ‌آپ هم ارسال کن
                        if not self.user.is_staff:  # اگر فرستنده ادمین نیست (یعنی کاربر عادی است)
                            if receiver.is_staff:  # و گیرنده ادمین است
                                await self.channel_layer.group_send(
                                    notification_group_name,
                                    {
                                        'type': 'chat_notification',
                                        'message': message[:50] + ('...' if len(message) > 50 else ''),
                                        'sender': self.user.username,
                                        'room_id': str(self.room_id),
                                        'is_admin': False
                                    }
                                )
                        elif not receiver.is_staff:  # اگر فرستنده ادمین است و گیرنده کاربر عادی
                            await self.channel_layer.group_send(
                                notification_group_name,
                                {
                                    'type': 'chat_notification',
                                    'message': message[:50] + ('...' if len(message) > 50 else ''),
                                    'sender': 'پشتیبانی',
                                    'room_id': str(self.room_id),
                                    'is_admin': True
                                }
                            )
                except Exception as e:
                    print(f"Error processing message: {e}")
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': f"خطا در پردازش پیام: {str(e)}"
                    }))

            elif message_type == 'typing':
                is_typing = data.get('is_typing', False)
                # ارسال وضعیت تایپ کردن به گروه چت
                await self.channel_layer.group_send(
                    self.room_group_name,
                    {
                        'type': 'typing_status',
                        'username': self.user.username,
                        'user_id': self.user.id,
                        'is_typing': is_typing,
                        'is_staff': self.user.is_staff
                    }
                )
            elif message_type == 'heartbeat':
                # دریافت heartbeat و بروزرسانی وضعیت آنلاین
                await self.set_user_status('online')
                await self.send(text_data=json.dumps({
                    'type': 'heartbeat_response',
                    'status': 'received'
                }))
        except json.JSONDecodeError as e:
            print(f"JSON decode error: {e}")
            await self.send(text_data=json.dumps({
                'type': 'error',
                'message': 'خطا در پردازش داده‌های دریافتی'
            }))
        except Exception as e:
            print(f"Unexpected error: {e}")
            await self.send(text_data=json.dumps({
                'type': 'error',
                'message': f'خطای غیرمنتظره: {str(e)}'
            }))

    async def chat_message(self, event):
        await self.send(text_data=json.dumps({
            'type': 'chat_message',
            'message': event['message'],
            'message_id': event['message_id'],
            'username': event['username'],
            'user_id': event['user_id'],
            'message_type': event.get('message_type', 'text'),
            'file_url': event.get('file_url', None),
            'file_name': event.get('file_name', None),
            'file_type': event.get('file_type', None),
            'timestamp': event.get('timestamp', None),
            'is_staff': event.get('is_staff', False)
        }))

    async def typing_status(self, event):
        await self.send(text_data=json.dumps({
            'type': 'typing',
            'username': event['username'],
            'user_id': event['user_id'],
            'is_typing': event['is_typing'],
            'is_staff': event.get('is_staff', False)
        }))

    async def user_status_update(self, event):
        """ارسال بروزرسانی وضعیت کاربر به کلاینت"""
        await self.send(text_data=json.dumps({
            'type': 'user_status_update',
            'user_id': event.get('user_id'),
            'username': event.get('username'),
            'status': event.get('status'),
            'is_staff': event.get('is_staff', False)
        }))

    async def message_read(self, event):
        await self.send(text_data=json.dumps({
            'type': 'message_read',
            'message_id': event['message_id'],
            'read_by_user_id': event['read_by_user_id']
        }))

    async def chat_deleted(self, event):
        await self.send(text_data=json.dumps({
            'type': 'chat_deleted',
            'deleted_by_user_id': event.get('deleted_by_user_id', None),
            'deleted_by': event.get('deleted_by', ''),
            'is_staff': event.get('is_staff', False)
        }))

    async def chat_status_update(self, event):
        await self.send(text_data=json.dumps({
            'type': 'chat_status_update',
            'is_closed': event['is_closed'],
            'updated_by_user_id': event.get('updated_by_user_id', None)
        }))

    async def chat_closed(self, event):
        await self.send(text_data=json.dumps({
            'type': 'chat_closed',
            'closed_by': event['closed_by'],
            'message': event['message']
        }))

    async def chat_system_message(self, event):
        """دریافت و ارسال پیام‌های سیستمی"""
        await self.send(text_data=json.dumps({
            'type': event['event_type'],
            'message': event['message'],
            'timestamp': event['timestamp'],
        }))

    @database_sync_to_async
    def is_chat_closed(self, room):
        """بررسی وضعیت بسته بودن چت"""
        return room.is_closed

    @database_sync_to_async
    def save_message(self, message):
        try:
            room = ChatRoom.objects.get(id=self.room_id)

            # بررسی وضعیت چت
            if room.is_closed:
                raise ValueError("این گفتگو بسته شده است و امکان ارسال پیام وجود ندارد.")

            chat_message = ChatMessage.objects.create(
                room=room,
                sender=self.user,
                content=message,
                message_type='text'
            )

            # بروزرسانی زمان آخرین فعالیت اتاق
            room.updated_at = timezone.now()
            room.save(update_fields=['updated_at'])

            return chat_message
        except Exception as e:
            print(f"Error saving message: {e}")
            raise

    @database_sync_to_async
    def get_room(self):
        """دریافت اطلاعات اتاق"""
        try:
            return ChatRoom.objects.get(id=self.room_id, is_active=True)
        except ChatRoom.DoesNotExist:
            return None

    @database_sync_to_async
    def get_other_user(self, room):
        """دریافت کاربر طرف مقابل در چت"""
        if not room:
            return None

        if self.user == room.user:
            return room.admin
        else:
            return room.user

    @database_sync_to_async
    def get_user_status(self, user):
        """دریافت وضعیت واقعی کاربر"""
        if not user:
            return 'offline'

        try:
            status_obj = UserChatStatus.objects.get(user=user)

            # استفاده از last_seen
            if status_obj.last_seen:
                # بررسی زمان آخرین فعالیت
                from datetime import timedelta
                threshold = timezone.now() - timedelta(minutes=2)

                if status_obj.last_seen > threshold:
                    return status_obj.status
                else:
                    return 'offline'
            else:
                return 'offline'

        except UserChatStatus.DoesNotExist:
            return 'offline'
        except Exception as e:
            print(f"Error in get_user_status: {e}")
            return 'offline'

    @database_sync_to_async
    def is_last_connection(self):
        # این تابع می‌تواند پیچیده‌تر شود برای بررسی اتصال‌های همزمان
        # فعلاً فرض می‌کنیم این آخرین اتصال است
        return True

    @database_sync_to_async
    def set_user_status(self, status):
        try:
            if hasattr(self.user, '_wrapped'):
                actual_user = self.user._wrapped
            else:
                actual_user = self.user

            if not actual_user or not actual_user.is_authenticated:
                return

            user_status, created = UserChatStatus.objects.get_or_create(
                user=actual_user,
                defaults={'status': status}
            )
            user_status.status = status
            user_status.last_seen = timezone.now()
            user_status.save()
        except Exception as e:
            print(f"Error setting user status: {e}")

    @database_sync_to_async
    def get_receiver(self):
        try:
            room = ChatRoom.objects.get(id=self.room_id)
            if self.user == room.user:
                return room.admin
            else:
                return room.user
        except Exception as e:
            print(f"Error in get_receiver: {e}")
            return None

    @database_sync_to_async
    def get_user_unread_count(self, user):
        try:
            if user.is_staff:
                return ChatMessage.objects.filter(
                    room__admin=user,
                    is_read=False,
                    sender__is_staff=False
                ).count()
            else:
                return ChatMessage.objects.filter(
                    room__user=user,
                    is_read=False,
                    sender__is_staff=True
                ).count()
        except Exception as e:
            print(f"Error in get_user_unread_count: {e}")
            return 0

    @database_sync_to_async
    def mark_messages_as_read(self):
        try:
            room = ChatRoom.objects.get(id=self.room_id)

            if self.user.is_staff:
                unread_messages = ChatMessage.objects.filter(
                    room=room,
                    is_read=False,
                    sender__is_staff=False
                )
            else:
                unread_messages = ChatMessage.objects.filter(
                    room=room,
                    is_read=False,
                    sender__is_staff=True
                )

            count = unread_messages.count()
            for message in unread_messages:
                message.is_read = True
                message.read_at = timezone.now()
                message.save()

            return count
        except Exception as e:
            print(f"Error marking messages as read: {e}")
            return 0

    @database_sync_to_async
    def save_message_with_file(self, message, file_data):
        try:
            room = ChatRoom.objects.get(id=self.room_id)

            # بررسی وضعیت چت
            if room.is_closed:
                raise ValueError("این گفتگو بسته شده است و امکان ارسال پیام وجود ندارد.")

            file_info = file_data.get('info', {})
            file_name = file_info.get('name', 'unnamed_file')
            file_type = file_info.get('type', 'application/octet-stream')

            max_size = 10 * 1024 * 1024  # 10MB

            file_content_str = file_data.get('content', '')
            if ',' in file_content_str:
                file_content_str = file_content_str.split(',', 1)[1]

            try:
                file_content = base64.b64decode(file_content_str)
            except Exception as e:
                raise ValueError(f"خطا در رمزگشایی فایل: {str(e)}")

            file_size = len(file_content)

            if file_size > max_size:
                raise ValueError(f"سایز فایل بیش از حد مجاز است (حداکثر {max_size / (1024 * 1024):.1f} مگابایت)")

            file_ext = os.path.splitext(file_name)[1]
            if not file_ext and '/' in file_type:
                mime_type = file_type.split('/')[1]
                if mime_type == 'jpeg':
                    file_ext = '.jpg'
                elif mime_type in ['png', 'gif', 'bmp', 'webp']:
                    file_ext = f'.{mime_type}'
                else:
                    file_ext = ''

            unique_filename = f"{uuid.uuid4()}{file_ext}"

            chat_message = ChatMessage(
                room=room,
                sender=self.user,
                content=message,
                file_name=file_name,
                file_type=file_type,
                file_size=file_size
            )

            chat_message.file.save(unique_filename, ContentFile(file_content), save=False)

            if file_type.startswith('image/'):
                chat_message.message_type = 'image'
            else:
                chat_message.message_type = 'file'

            chat_message.save()

            # بروزرسانی زمان آخرین فعالیت اتاق
            room.updated_at = timezone.now()
            room.save(update_fields=['updated_at'])

            file_url = chat_message.file.url if chat_message.file else None

            return chat_message
        except Exception as e:
            print(f"Error saving message with file: {e}")
            raise


class NotificationConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.user = self.scope["user"]

        if isinstance(self.user, AnonymousUser) or not self.user.is_authenticated:
            await self.close()
            return

        self.notification_group_name = f'notifications_{self.user.id}'

        await self.channel_layer.group_add(
            self.notification_group_name,
            self.channel_name
        )

        await self.accept()

        await self.set_user_status('online')

        unread_count = await self.get_unread_count()
        await self.send(text_data=json.dumps({
            'type': 'unread_count',
            'count': unread_count
        }))

    async def disconnect(self, close_code):
        if hasattr(self, 'notification_group_name'):
            await self.channel_layer.group_discard(
                self.notification_group_name,
                self.channel_name
            )

        if hasattr(self, 'user') and self.user.is_authenticated:
            if await self.is_last_connection():
                await self.set_user_status('offline')

    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type')

            if message_type == 'check_unread':
                unread_count = await self.get_unread_count()
                await self.send(text_data=json.dumps({
                    'type': 'unread_count',
                    'count': unread_count
                }))
            elif message_type == 'ping':
                await self.send(text_data=json.dumps({
                    'type': 'pong',
                    'message': 'Connection is alive'
                }))
            elif message_type == 'heartbeat':
                await self.set_user_status('online')
                await self.send(text_data=json.dumps({
                    'type': 'heartbeat_response',
                    'status': 'received'
                }))
            elif message_type == 'set_status':
                status = data.get('status', 'online')
                await self.set_user_status(status)
                await self.notify_user_status_change(status)
            elif message_type == 'offline':
                await self.set_user_status('offline')
                await self.notify_user_status_change('offline')
        except json.JSONDecodeError:
            pass
        except Exception as e:
            print(f"Error in NotificationConsumer.receive: {e}")

    async def user_status_update(self, event):
        """Handle user status updates"""
        await self.send(text_data=json.dumps({
            'type': 'user_status_update',
            'user_id': event.get('user_id'),
            'username': event.get('username'),
            'status': event.get('status'),
            'is_staff': event.get('is_staff', False)
        }))

    async def chat_notification(self, event):
        await self.send(text_data=json.dumps({
            'type': 'chat_notification',
            'message': event['message'],
            'sender': event['sender'],
            'room_id': event['room_id'],
            'is_admin': event['is_admin']
        }))

    async def unread_count_update(self, event):
        await self.send(text_data=json.dumps({
            'type': 'unread_count',
            'count': event['count']
        }))

    async def notification_message(self, event):
        """Handle general notification messages"""
        await self.send(text_data=json.dumps({
            'type': 'notification',
            'message': event.get('message', ''),
            'title': event.get('title', ''),
            'data': event.get('data', {})
        }))

    @database_sync_to_async
    def is_last_connection(self):
        # این تابع می‌تواند پیچیده‌تر شود برای بررسی اتصال‌های همزمان
        # فعلاً فرض می‌کنیم این آخرین اتصال است
        return True

    @database_sync_to_async
    def set_user_status(self, status):
        try:
            if hasattr(self.user, '_wrapped'):
                actual_user = self.user._wrapped
            else:
                actual_user = self.user

            if not actual_user or not actual_user.is_authenticated:
                return

            user_status, created = UserChatStatus.objects.get_or_create(
                user=actual_user,
                defaults={'status': status}
            )
            user_status.status = status
            user_status.last_seen = timezone.now()
            user_status.save()

            return True
        except Exception as e:
            print(f"Error setting user status: {e}")
            return False

    async def notify_user_status_change(self, status):
        try:
            chat_rooms = await self.get_user_chat_rooms()

            for room in chat_rooms:
                room_group_name = f'chat_{room.id}'

                await self.channel_layer.group_send(
                    room_group_name,
                    {
                        'type': 'user_status_update',
                        'user_id': self.user.id,
                        'username': self.user.username,
                        'status': status,
                        'is_staff': self.user.is_staff
                    }
                )
        except Exception as e:
            print(f"Error notifying status change: {e}")

    @database_sync_to_async
    def get_user_chat_rooms(self):
        if self.user.is_staff:
            return list(ChatRoom.objects.filter(admin=self.user, is_active=True))
        else:
            return list(ChatRoom.objects.filter(user=self.user, is_active=True))

    @database_sync_to_async
    def get_unread_count(self):
        if not self.user.is_authenticated:
            return 0

        try:
            if self.user.is_staff:
                # پیام‌های خوانده نشده در چت‌های اختصاص داده شده به این ادمین
                unread_count = ChatMessage.objects.filter(
                    room__admin=self.user,
                    is_read=False,
                    sender__is_staff=False
                ).count()

                # چت‌های در انتظار (بدون ادمین)
                pending_count = ChatRoom.objects.filter(
                    is_active=True,
                    admin=None,
                    is_closed=False
                ).count()

                return unread_count + pending_count
            else:
                return ChatMessage.objects.filter(
                    room__user=self.user,
                    is_read=False,
                    sender__is_staff=True
                ).count()
        except Exception as e:
            print(f"Error in get_unread_count: {e}")
            return 0


class OnlineStatusConsumer(AsyncWebsocketConsumer):

    async def connect(self):
        self.user = self.scope["user"]

        # بررسی احراز هویت کاربر
        if isinstance(self.user, AnonymousUser) or not self.user.is_authenticated:
            await self.close()
            return

        self.user_group_name = f'user_status_{self.user.id}'

        await self.channel_layer.group_add(
            self.user_group_name,
            self.channel_name
        )

        await self.accept()

        await self.set_user_status('online')

        await self.notify_user_status_change('online')

    async def disconnect(self, close_code):
        if hasattr(self, 'user_group_name'):
            await self.channel_layer.group_discard(
                self.user_group_name,
                self.channel_name
            )

        if hasattr(self, 'user') and self.user.is_authenticated:
            if await self.is_last_connection():
                await self.set_user_status('offline')
                await self.notify_user_status_change('offline')

    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            message_type = data.get('type')

            if message_type == 'heartbeat':
                await self.set_user_status('online')
                await self.send(text_data=json.dumps({
                    'type': 'heartbeat_response',
                    'status': 'received'
                }))
            elif message_type == 'set_status':
                status = data.get('status', 'online')
                await self.set_user_status(status)
                await self.notify_user_status_change(status)
            elif message_type == 'check_status':
                user_id = data.get('user_id')
                if user_id:
                    status = await self.get_user_status_by_id(user_id)
                    await self.send(text_data=json.dumps({
                        'type': 'user_status',
                        'user_id': user_id,
                        'status': status
                    }))
            elif message_type == 'offline':
                await self.set_user_status('offline')
                await self.notify_user_status_change('offline')
        except json.JSONDecodeError:
            pass
        except Exception as e:
            print(f"Error in OnlineStatusConsumer.receive: {e}")

    async def status_update(self, event):
        """ارسال بروزرسانی وضعیت به کلاینت"""
        await self.send(text_data=json.dumps({
            'type': 'status_update',
            'user_id': event.get('user_id'),
            'status': event.get('status')
        }))

    @database_sync_to_async
    def get_user_chat_rooms(self):
        if self.user.is_staff:
            return list(ChatRoom.objects.filter(admin=self.user, is_active=True))
        else:
            return list(ChatRoom.objects.filter(user=self.user, is_active=True))

    @database_sync_to_async
    def is_last_connection(self):
        # این تابع می‌تواند پیچیده‌تر شود برای بررسی اتصال‌های همزمان
        # فعلاً فرض می‌کنیم این آخرین اتصال است
        return True

    @database_sync_to_async
    def set_user_status(self, status):
        try:
            if hasattr(self.user, '_wrapped'):
                actual_user = self.user._wrapped
            else:
                actual_user = self.user

            if not actual_user or not actual_user.is_authenticated:
                return

            user_status, created = UserChatStatus.objects.get_or_create(
                user=actual_user,
                defaults={'status': status}
            )
            user_status.status = status
            user_status.last_seen = timezone.now()
            user_status.save()

            return True
        except Exception as e:
            print(f"Error setting user status: {e}")
            return False

    @database_sync_to_async
    def get_user_status_by_id(self, user_id):
        try:
            user = User.objects.get(id=user_id)
            status_obj = UserChatStatus.objects.filter(user=user).first()

            if status_obj:
                from datetime import timedelta
                threshold = timezone.now() - timedelta(minutes=2)

                if status_obj.last_seen and status_obj.last_seen > threshold:
                    return status_obj.status
                else:
                    return 'offline'
            else:
                return 'offline'
        except User.DoesNotExist:
            return 'offline'
        except Exception as e:
            print(f"Error getting user status: {e}")
            return 'offline'

    async def notify_user_status_change(self, status):
        try:
            # دریافت تمام اتاق‌های چت فعال کاربر
            chat_rooms = await self.get_user_chat_rooms()

            for room in chat_rooms:
                room_group_name = f'chat_{room.id}'

                await self.channel_layer.group_send(
                    room_group_name,
                    {
                        'type': 'user_status_update',
                        'user_id': self.user.id,
                        'username': self.user.username,
                        'status': status,
                        'is_staff': self.user.is_staff
                    }
                )
        except Exception as e:
            print(f"Error notifying status change: {e}")

====== FILE: chat/middleware.py ======

from django.utils import timezone
from .models import UserChatStatus


class UserActivityMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)

        # بروزرسانی آخرین زمان فعالیت کاربر
        if request.user.is_authenticated:
            try:
                status, created = UserChatStatus.objects.get_or_create(user=request.user)
                status.last_seen = timezone.now()
                if request.path != '/chat/set-offline/':  # اگر درخواست برای آفلاین شدن نیست
                    status.status = 'online'
                status.save(update_fields=['last_seen', 'status'])
            except Exception as e:
                pass

        return response

====== FILE: chat/__init__.py ======



====== FILE: chat/admin.py ======

# chat/admin.py
from django.contrib import admin
from .models import ChatRoom, ChatMessage, UserChatStatus, Notification


@admin.register(ChatRoom)
class ChatRoomAdmin(admin.ModelAdmin):
    list_display = ('name', 'room_type', 'is_active', 'created_at')
    list_filter = ('room_type', 'is_active')
    search_fields = ('name',)
    filter_horizontal = ('participants',)


@admin.register(ChatMessage)
class ChatMessageAdmin(admin.ModelAdmin):
    list_display = ('sender', 'room', 'message_type', 'content_preview', 'created_at')
    list_filter = ('message_type', 'is_read')
    search_fields = ('content',)

    def content_preview(self, obj):
        return obj.content[:50] + '...' if len(obj.content) > 50 else obj.content

    content_preview.short_description = 'محتوا'


@admin.register(UserChatStatus)
class UserChatStatusAdmin(admin.ModelAdmin):
    list_display = ('user', 'status', 'last_seen', 'is_staff_available')
    list_filter = ('status', 'is_staff_available')
    search_fields = ('user__username',)


@admin.register(Notification)
class NotificationAdmin(admin.ModelAdmin):
    list_display = ('user', 'notification_type', 'title', 'is_read', 'created_at')
    list_filter = ('notification_type', 'is_read')
    search_fields = ('title', 'message')

====== FILE: chat/signals.py ======

from django.contrib.auth import user_logged_in, user_logged_out
from django.dispatch import receiver
from django.db.models.signals import post_save
from django.contrib.auth import get_user_model
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from .models import UserChatStatus, ChatRoom

User = get_user_model()


@receiver(post_save, sender=User)
def create_user_chat_status(sender, instance, created, **kwargs):
    """ایجاد وضعیت چت برای کاربران جدید"""
    if created:
        UserChatStatus.objects.create(user=instance)


@receiver(user_logged_in)
def user_logged_in_handler(sender, request, user, **kwargs):
    """تغییر وضعیت کاربر به آنلاین هنگام ورود"""
    try:
        status, created = UserChatStatus.objects.get_or_create(user=user)
        status.status = 'online'
        status.save()

        # اطلاع‌رسانی به اتاق‌های چت کاربر
        notify_status_change(user, 'online')
    except Exception as e:
        print(f"Error updating user status on login: {e}")


@receiver(user_logged_out)
def user_logged_out_handler(sender, request, user, **kwargs):
    """تغییر وضعیت کاربر به آفلاین هنگام خروج"""
    if user and not user.is_anonymous:
        try:
            status = UserChatStatus.objects.filter(user=user).first()
            if status:
                status.status = 'offline'
                status.save()

                # اطلاع‌رسانی به اتاق‌های چت کاربر
                notify_status_change(user, 'offline')
        except Exception as e:
            print(f"Error updating user status on logout: {e}")


def notify_status_change(user, status):
    """اطلاع‌رسانی تغییر وضعیت کاربر به اتاق‌های چت مرتبط"""
    try:
        channel_layer = get_channel_layer()

        # دریافت تمام اتاق‌های چت کاربر
        if user.is_staff:
            chat_rooms = ChatRoom.objects.filter(admin=user)
        else:
            chat_rooms = ChatRoom.objects.filter(user=user)

        # ارسال اطلاعیه به هر اتاق
        for room in chat_rooms:
            async_to_sync(channel_layer.group_send)(
                f'chat_{room.id}',
                {
                    'type': 'user_status_update',
                    'user_id': user.id,
                    'username': user.username,
                    'status': status,
                    'is_staff': user.is_staff
                }
            )

        # همچنین اطلاع‌رسانی به کانال اعلان‌های کاربر برای بروزرسانی آیکن وضعیت
        notification_group = f'notifications_{user.id}'
        async_to_sync(channel_layer.group_send)(
            notification_group,
            {
                'type': 'user_status_update',
                'user_id': user.id,
                'username': user.username,
                'status': status,
                'is_staff': user.is_staff
            }
        )
    except Exception as e:
        print(f"Error notifying status change: {e}")

====== FILE: chat/utils.py ======

# chat/utils.py
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
import json
from django.utils import timezone


def notify_chat_closed_by_user(room):
    """
    ارسال اطلاع‌رسانی به ادمین مبنی بر بسته شدن چت توسط کاربر
    """
    if not room.admin:
        return

    channel_layer = get_channel_layer()

    # ارسال پیام به گروه چت
    async_to_sync(channel_layer.group_send)(
        f"chat_{room.id}",
        {
            "type": "chat_system_message",
            "event_type": "chat_closed_by_user",
            "message": "این گفتگو توسط کاربر بسته شده است.",
            "timestamp": timezone.now().isoformat(),
        }
    )

    # ارسال اطلاع‌رسانی به ادمین
    async_to_sync(channel_layer.group_send)(
        f"notifications_{room.admin.id}",
        {
            "type": "notification_message",
            "message": f"گفتگو با {room.user.username} توسط کاربر بسته شده است.",
            "title": "بستن گفتگو",
            "data": {
                "chat_id": str(room.id),
                "event_type": "chat_closed_by_user",
            }
        }
    )


def notify_chat_closed_by_admin(room):
    """
    ارسال اطلاع‌رسانی به کاربر مبنی بر بسته شدن چت توسط ادمین
    """
    channel_layer = get_channel_layer()

    # ارسال پیام به گروه چت
    async_to_sync(channel_layer.group_send)(
        f"chat_{room.id}",
        {
            "type": "chat_system_message",
            "event_type": "chat_closed_by_admin",
            "message": "این گفتگو توسط پشتیبانی بسته شده است.",
            "timestamp": timezone.now().isoformat(),
        }
    )

    # ارسال اطلاع‌رسانی به کاربر
    if room.user:
        async_to_sync(channel_layer.group_send)(
            f"notifications_{room.user.id}",
            {
                "type": "notification_message",
                "message": "گفتگوی شما با پشتیبانی بسته شده است.",
                "title": "بستن گفتگو",
                "data": {
                    "chat_id": str(room.id),
                    "event_type": "chat_closed_by_admin",
                }
            }
        )


def notify_chat_reopened(room):
    """
    ارسال اطلاع‌رسانی به کاربر مبنی بر بازگشایی چت
    """
    channel_layer = get_channel_layer()

    # ارسال پیام به گروه چت
    async_to_sync(channel_layer.group_send)(
        f"chat_{room.id}",
        {
            "type": "chat_system_message",
            "event_type": "chat_reopened",
            "message": "این گفتگو بازگشایی شده است.",
            "timestamp": timezone.now().isoformat(),
        }
    )

    # ارسال اطلاع‌رسانی به کاربر
    if room.user:
        async_to_sync(channel_layer.group_send)(
            f"notifications_{room.user.id}",
            {
                "type": "notification_message",
                "message": "گفتگوی شما با پشتیبانی بازگشایی شده است.",
                "title": "بازگشایی گفتگو",
                "data": {
                    "chat_id": str(room.id),
                    "event_type": "chat_reopened",
                }
            }
        )


def create_system_message(room, content):
    """
    ایجاد یک پیام سیستمی در دیتابیس
    """
    from .models import ChatMessage

    # تعیین فرستنده برای پیام سیستمی - ترجیحاً از ادمین استفاده می‌کنیم
    # اگر ادمین وجود نداشت از کاربر استفاده می‌کنیم
    sender = room.admin if room.admin else room.user

    # اگر هیچ کاربری وجود نداشت، از سوپر یوزر استفاده می‌کنیم
    if not sender:
        from django.contrib.auth import get_user_model
        User = get_user_model()
        sender = User.objects.filter(is_superuser=True).first()

        # اگر حتی سوپر یوزر هم وجود نداشت، خطا می‌دهیم
        if not sender:
            raise ValueError("هیچ کاربری برای ارسال پیام سیستمی یافت نشد.")

    message = ChatMessage.objects.create(
        room=room,
        content=content,
        message_type='system',
        is_read=True,  # پیام‌های سیستمی همیشه خوانده شده محسوب می‌شوند
        sender=sender   # تعیین فرستنده برای پیام سیستمی
    )
    return message

====== FILE: chat/models.py ======

import os

from django.db import models
from django.conf import settings
from django.utils import timezone
import uuid


class ChatRoom(models.Model):
    """اتاق چت"""
    ROOM_TYPES = [
        ('support', 'پشتیبانی'),
        ('general', 'عمومی'),
        ('private', 'خصوصی'),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField('نام اتاق', max_length=100, default="گفتگوی پشتیبانی")
    room_type = models.CharField('نوع اتاق', max_length=20, choices=ROOM_TYPES, default='support')
    participants = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='chat_rooms', blank=True)
    is_active = models.BooleanField('فعال', default=True)
    created_at = models.DateTimeField('تاریخ ایجاد', auto_now_add=True)
    updated_at = models.DateTimeField('تاریخ بروزرسانی', auto_now=True)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='user_chat_rooms', null=True, blank=True)
    admin = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='admin_chat_rooms', null=True, blank=True)
    is_closed_by_admin = models.BooleanField(default=False)
    is_closed_by_user = models.BooleanField(default=False)
    is_closed = models.BooleanField(default=False)
    closed_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        verbose_name = 'اتاق چت'
        verbose_name_plural = 'اتاق‌های چت'
        ordering = ['-updated_at']

    def save(self, *args, **kwargs):
        # تنظیم is_closed بر اساس مقادیر is_closed_by_user و is_closed_by_admin
        self.is_closed = self.is_closed_by_user or self.is_closed_by_admin
        super().save(*args, **kwargs)

    def close_by_user(self):
        """بستن چت توسط کاربر"""
        self.is_closed_by_user = True
        self.closed_at = timezone.now()
        self.save()

        # ایجاد پیام سیستمی
        from .utils import create_system_message
        try:
            create_system_message(self, "این گفتگو توسط کاربر بسته شده است.")
        except Exception as e:
            print(f"خطا در ایجاد پیام سیستمی: {e}")

    def close_by_admin(self):
        """بستن چت توسط ادمین"""
        self.is_closed_by_admin = True
        self.closed_at = timezone.now()
        self.save()

        # ایجاد پیام سیستمی
        from .utils import create_system_message
        try:
            create_system_message(self, "این گفتگو توسط پشتیبانی بسته شده است.")
        except Exception as e:
            print(f"خطا در ایجاد پیام سیستمی: {e}")

    def __str__(self):
        user_name = self.user.username if self.user else "بدون کاربر"
        return f"{user_name} - {self.name}"

    @property
    def group_name(self):
        """نام گروه برای channels"""
        return f'chat_{self.id}'


class ChatMessage(models.Model):
    MESSAGE_TYPES = (
        ('text', 'Text'),
        ('image', 'Image'),
        ('file', 'File'),
        ('system', 'System'),
    )

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    room = models.ForeignKey(ChatRoom, on_delete=models.CASCADE, related_name='messages')
    sender = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True,
                               related_name='sent_messages')
    content = models.TextField()
    file = models.FileField(upload_to='chat_files/%Y/%m/%d/', null=True, blank=True)
    file_name = models.CharField(max_length=255, null=True, blank=True)
    file_size = models.PositiveIntegerField(null=True, blank=True)
    file_type = models.CharField(max_length=100, null=True, blank=True)
    message_type = models.CharField(max_length=10, choices=MESSAGE_TYPES, default='text')
    is_read = models.BooleanField(default=False)
    read_at = models.DateTimeField(null=True, blank=True)  # اضافه کردن این فیلد
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['created_at']

    def __str__(self):
        return f"{self.sender.username if self.sender else 'System'}: {self.content[:50]}"

    def mark_as_read(self):
        if not self.is_read:
            self.is_read = True
            self.read_at = timezone.now()  # تنظیم زمان خوانده شدن
            self.save()

    def save(self, *args, **kwargs):
        # اگر فایل آپلود شده و نوع پیام مشخص نشده، نوع پیام را تعیین کن
        if self.file and (not self.message_type or self.message_type == 'text'):
            file_ext = os.path.splitext(self.file.name)[1].lower() if self.file.name else ''
            image_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']

            if file_ext in image_extensions:
                self.message_type = 'image'
            else:
                self.message_type = 'file'

            # ذخیره نام فایل و سایز آن
            if not self.file_name and self.file:
                self.file_name = os.path.basename(self.file.name)

            # سایز فایل را ذخیره کن
            if not self.file_size and hasattr(self.file, 'size'):
                self.file_size = self.file.size

            # نوع فایل را ذخیره کن
            if not self.file_type and self.file:
                import mimetypes
                self.file_type = mimetypes.guess_type(self.file.name)[0] or 'application/octet-stream'

        super().save(*args, **kwargs)


class UserChatStatus(models.Model):
    """وضعیت آنلاین کاربران"""
    STATUS_CHOICES = [
        ('online', 'آنلاین'),
        ('away', 'غایب'),
        ('busy', 'مشغول'),
        ('offline', 'آفلاین'),
    ]

    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='chat_status')
    status = models.CharField('وضعیت', max_length=20, choices=STATUS_CHOICES, default='offline')
    last_seen = models.DateTimeField('آخرین بازدید', auto_now=True)
    is_staff_available = models.BooleanField('ادمین در دسترس', default=False)

    class Meta:
        verbose_name = 'وضعیت چت کاربر'
        verbose_name_plural = 'وضعیت چت کاربران'

    def __str__(self):
        return f"{self.user.username} - {self.get_status_display()}"


class Notification(models.Model):
    """نوتیفیکیشن‌ها"""
    NOTIFICATION_TYPES = [
        ('chat', 'پیام چت'),
        ('order', 'بروزرسانی سفارش'),
        ('product', 'موجود شدن محصول'),
        ('system', 'سیستم'),
    ]

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='notifications')
    notification_type = models.CharField('نوع نوتیفیکیشن', max_length=30, choices=NOTIFICATION_TYPES)
    title = models.CharField('عنوان', max_length=200)
    message = models.TextField('پیام')
    data = models.JSONField('داده‌های اضافی', default=dict, blank=True)
    is_read = models.BooleanField('خوانده شده', default=False)
    created_at = models.DateTimeField('تاریخ ایجاد', auto_now_add=True)

    class Meta:
        verbose_name = 'نوتیفیکیشن'
        verbose_name_plural = 'نوتیفیکیشن‌ها'
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.user.username}: {self.title}"


class DeletedChat(models.Model):
    """مدل برای ذخیره چت‌هایی که کاربر حذف کرده است"""
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    room = models.ForeignKey(ChatRoom, on_delete=models.CASCADE, related_name='deleted_by')
    deleted_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ('user', 'room')

    def __str__(self):
        return f"{self.user.username} deleted chat {self.room.id}"

====== FILE: chat/apps.py ======

from django.apps import AppConfig


class ChatConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chat'

    def ready(self):
        import chat.signals

====== FILE: chat/views.py ======

from datetime import timedelta

from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer
from django.contrib.admin.views.decorators import staff_member_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.contrib import messages
from django.db.models import Q, Count
from django.template.loader import render_to_string
from django.contrib.auth import get_user_model
from django.utils import timezone
from django.views import View
from django.views.decorators.http import require_POST

from .models import ChatRoom, ChatMessage, UserChatStatus, Notification, DeletedChat
import uuid
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator

from .utils import notify_chat_reopened, notify_chat_closed_by_admin, notify_chat_closed_by_user

User = get_user_model()


@login_required
def chat_list(request):
    user_chats = ChatRoom.objects.filter(
        user=request.user,
        is_active=True,
    ).exclude(
        id__in=DeletedChat.objects.filter(user=request.user).values('room_id')  # حذف چت‌های حذف شده توسط کاربر
    ).order_by('-updated_at')

    for chat in user_chats:
        chat.unread_count = ChatMessage.objects.filter(
            room=chat,
            is_read=False
        ).exclude(sender=request.user).count()

    context = {
        'user_chats': user_chats,
    }

    return render(request, 'chat/chat_list.html', context)


@login_required
def chat_room(request, room_id):
    try:
        room = ChatRoom.objects.get(id=room_id)

        # بررسی دسترسی کاربر
        if not request.user.is_staff and request.user != room.user:
            messages.error(request, 'شما اجازه دسترسی به این چت را ندارید.')
            return redirect('chat:chat_list')

        # بررسی اگر کاربر عادی این چت را حذف کرده است
        is_deleted_by_user = DeletedChat.objects.filter(room=room, user=room.user).exists()

        # خواندن پیام‌های نخوانده
        if request.user.is_staff:
            unread_messages = room.messages.filter(is_read=False, sender=room.user)
        else:
            unread_messages = room.messages.filter(is_read=False, sender__is_staff=True)

        # ارسال رویداد خوانده شدن پیام به وب‌سوکت
        channel_layer = get_channel_layer()
        for message in unread_messages:
            message.is_read = True
            message.read_at = timezone.now()
            message.save()

            try:
                async_to_sync(channel_layer.group_send)(
                    f'chat_{room.id}',
                    {
                        'type': 'message_read',
                        'message_id': str(message.id),
                        'read_by_user_id': request.user.id
                    }
                )
            except Exception as e:
                print(f"Error sending to channel: {e}")

        chat_messages = room.messages.all().order_by('created_at')

        # بررسی وضعیت آنلاین کاربران اتاق
        users_to_check = [room.user]
        if room.admin:
            users_to_check.append(room.admin)

        online_users = UserChatStatus.objects.filter(
            status='online',
            user__in=users_to_check
        )

        context = {
            'room': room,
            'room_id_str': str(room.id),
            'chat_messages': chat_messages,
            'online_users': online_users,
            'is_deleted_by_user': is_deleted_by_user,
        }

        return render(request, 'chat/chat_room.html', context)

    except ChatRoom.DoesNotExist:
        messages.error(request, 'چت مورد نظر یافت نشد.')
        return redirect('chat:chat_list')


@login_required
@require_POST
def mark_message_as_read(request, message_id):
    try:
        message = ChatMessage.objects.get(id=message_id)

        if not request.user.is_staff and request.user != message.room.user:
            return JsonResponse({'success': False, 'error': 'شما اجازه دسترسی به این پیام را ندارید.'})

        if message.is_read:
            return JsonResponse({'success': True, 'already_read': True})

        message.is_read = True
        message.read_at = timezone.now()
        message.save()

        try:
            channel_layer = get_channel_layer()
            async_to_sync(channel_layer.group_send)(
                f'chat_{message.room.id}',
                {
                    'type': 'message_read',
                    'message_id': str(message.id),
                    'read_by_user_id': request.user.id
                }
            )
        except Exception as e:
            print(f"Error sending to channel: {e}")

        return JsonResponse({'success': True})

    except ChatMessage.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'پیام مورد نظر یافت نشد.'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


@login_required
def start_chat(request):
    if request.user.is_staff:
        return redirect('chat:admin_dashboard')

    if request.method == 'POST':
        # بررسی آیا کاربر قبلاً چت فعال دارد
        existing_active_chat = ChatRoom.objects.filter(
            user=request.user,
            is_active=True,
            is_closed=False
        ).exclude(
            id__in=DeletedChat.objects.filter(user=request.user).values('room_id')
        ).first()

        if existing_active_chat:
            return redirect('chat:chat_room', room_id=existing_active_chat.id)

        # ایجاد چت جدید
        new_chat = ChatRoom.objects.create(
            user=request.user,
            name=f"گفتگوی پشتیبانی {request.user.username}",
            is_active=True
        )

        # ایجاد پیام خوش‌آمدگویی سیستمی
        ChatMessage.objects.create(
            room=new_chat,
            content="به پشتیبانی زیما خوش آمدید. چگونه می‌توانیم به شما کمک کنیم؟",
            message_type="system",
            sender=None  # پیام سیستمی بدون فرستنده
        )

        # اطلاع‌رسانی به ادمین‌ها درباره چت جدید
        admins = User.objects.filter(is_staff=True)
        channel_layer = get_channel_layer()
        for admin in admins:
            try:
                notification_group_name = f'notifications_{admin.id}'
                async_to_sync(channel_layer.group_send)(
                    notification_group_name,
                    {
                        'type': 'notification_message',
                        'title': 'چت جدید',
                        'message': f'کاربر {request.user.username} یک چت جدید ایجاد کرده است',
                        'data': {
                            'room_id': str(new_chat.id)
                        }
                    }
                )
            except Exception as e:
                print(f"Error sending notification to admin {admin.id}: {e}")

        return redirect('chat:chat_room', room_id=new_chat.id)

    return render(request, 'chat/start_chat.html')


@login_required
@require_POST
def delete_chat(request, room_id):
    """حذف (مخفی کردن) چت برای کاربر"""
    try:
        room = get_object_or_404(ChatRoom, id=room_id)

        if room.user != request.user and not request.user.is_staff:
            return JsonResponse({
                'success': False,
                'error': 'شما اجازه حذف این گفتگو را ندارید'
            })

        # ارسال اعلان به کلاینت‌ها
        channel_layer = get_channel_layer()
        try:
            async_to_sync(channel_layer.group_send)(
                f'chat_{room_id}',
                {
                    'type': 'chat_deleted',
                    'deleted_by_user_id': request.user.id,
                    'deleted_by': request.user.username,
                    'is_staff': request.user.is_staff
                }
            )
        except Exception as e:
            print(f"Error sending delete notification: {e}")

        # اگر ادمین حذف کرد، کل چت حذف شود
        if request.user.is_staff:
            # به جای حذف کامل، چت را غیرفعال کنیم
            room.is_active = False
            room.save()
            return JsonResponse({'success': True})
        else:
            # اگر کاربر عادی حذف کرد، فقط برای او مخفی شود
            DeletedChat.objects.get_or_create(user=request.user, room=room)
            return JsonResponse({'success': True})

    except ChatRoom.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'گفتگوی مورد نظر یافت نشد'
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        })


@staff_member_required
def api_user_closed_chats(request):
    """API برای دریافت چت‌های بسته شده توسط کاربر"""
    try:
        user_closed_chats = ChatRoom.objects.filter(
            admin=request.user,
            is_closed_by_user=True,
            is_closed_by_admin=False,
            is_active=True
        ).order_by('-updated_at')

        html = render_to_string('chat/partials/user_closed_chats.html', {
            'user_closed_chats': user_closed_chats,
        }, request=request)

        return JsonResponse({
            'status': 'success',
            'html': html
        })
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'error': str(e)
        })


@login_required
@require_POST
def close_chat(request, room_id):
    room = get_object_or_404(ChatRoom, id=room_id)

    # بررسی دسترسی کاربر
    if not (request.user.is_staff or request.user == room.user):
        return JsonResponse({"status": "error", "message": "شما اجازه بستن این گفتگو را ندارید."})

    # بستن چت توسط ادمین یا کاربر
    if request.user.is_staff:
        room.close_by_admin()
        message = "گفتگو توسط پشتیبانی بسته شده است."
        closed_by = "admin"
    else:
        room.close_by_user()
        message = "گفتگو توسط کاربر بسته شده است."
        closed_by = "user"

    # ارسال پیام از طریق WebSocket
    channel_layer = get_channel_layer()
    async_to_sync(channel_layer.group_send)(
        f"chat_{room_id}",
        {
            "type": "chat_closed",
            "closed_by": closed_by,
            "message": message
        }
    )

    return JsonResponse({"status": "success"})


@login_required
def user_close_chat(request, room_id):
    """بستن چت توسط کاربر"""
    try:
        room = get_object_or_404(ChatRoom, id=room_id, user=request.user)
        room.is_closed_by_user = True
        room.closed_at = timezone.now()
        room.save()

        # ارسال اطلاع‌رسانی به ادمین
        notify_chat_closed_by_user(room)

        return JsonResponse({'status': 'success'})
    except ChatRoom.DoesNotExist:
        return JsonResponse({'status': 'error', 'error': 'چت مورد نظر یافت نشد.'})


@staff_member_required
def admin_close_chat(request, room_id):
    """بستن چت توسط ادمین"""
    try:
        room = get_object_or_404(ChatRoom, id=room_id)

        # بررسی اینکه آیا این ادمین مسئول این چت است
        if room.admin and room.admin != request.user:
            return JsonResponse({'status': 'error', 'error': 'این چت به شما اختصاص داده نشده است.'})

        room.is_closed_by_admin = True
        room.closed_at = timezone.now()
        room.save()

        # ارسال اطلاع‌رسانی به کاربر
        notify_chat_closed_by_admin(room)

        return JsonResponse({'status': 'success'})
    except ChatRoom.DoesNotExist:
        return JsonResponse({'status': 'error', 'error': 'چت مورد نظر یافت نشد.'})


@staff_member_required
def reopen_chat(request, room_id):
    """بازگشایی چت توسط ادمین"""
    try:
        room = get_object_or_404(ChatRoom, id=room_id)

        # بررسی اینکه آیا این ادمین مسئول این چت است
        if room.admin and room.admin != request.user:
            return JsonResponse({'status': 'error', 'error': 'این چت به شما اختصاص داده نشده است.'})

        room.is_closed_by_admin = False
        room.is_closed_by_user = False
        room.save()

        # ارسال اطلاع‌رسانی به کاربر
        notify_chat_reopened(room)

        return JsonResponse({'status': 'success'})
    except ChatRoom.DoesNotExist:
        return JsonResponse({'status': 'error', 'error': 'چت مورد نظر یافت نشد.'})


@staff_member_required
def archive_chat(request, room_id):
    """بایگانی چت توسط ادمین"""
    try:
        room = get_object_or_404(ChatRoom, id=room_id)

        # بررسی اینکه آیا این ادمین مسئول این چت است
        if room.admin and room.admin != request.user:
            return JsonResponse({'status': 'error', 'error': 'این چت به شما اختصاص داده نشده است.'})

        room.is_closed_by_admin = True
        room.closed_at = timezone.now()
        room.save()

        return JsonResponse({'status': 'success'})
    except ChatRoom.DoesNotExist:
        return JsonResponse({'status': 'error', 'error': 'چت مورد نظر یافت نشد.'})


@login_required
def assign_admin(request, room_id):
    if not request.user.is_staff:
        return JsonResponse({'success': False, 'error': 'دسترسی غیرمجاز'})

    try:
        room = get_object_or_404(ChatRoom, id=room_id)

        # اگر چت قبلاً به ادمین دیگری اختصاص داده شده، اطلاع دهیم
        if room.admin and room.admin != request.user:
            return JsonResponse(
                {'success': False, 'error': f'این چت قبلاً به {room.admin.username} اختصاص داده شده است.'})

        room.admin = request.user
        room.save()

        # اضافه کردن ادمین به شرکت‌کنندگان چت
        room.participants.add(request.user)

        # ایجاد پیام سیستمی
        admin_name = request.user.get_full_name() or request.user.username
        system_message = f'این چت به {admin_name} اختصاص یافت.'

        ChatMessage.objects.create(
            room=room,
            content=system_message,
            message_type='system',
            sender=None  # پیام سیستمی
        )

        # اطلاع‌رسانی به کاربران چت
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            f'chat_{room_id}',
            {
                'type': 'chat_system_message',
                'event_type': 'system_message',
                'message': system_message,
                'timestamp': timezone.now().isoformat()
            }
        )

        return JsonResponse({'success': True})

    except ChatRoom.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'چت مورد نظر یافت نشد'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


@login_required
def admin_dashboard(request):
    if not request.user.is_staff:
        return redirect('chat:chat_list')

    # شمارش چت‌های فعال
    active_chats = ChatRoom.objects.filter(is_active=True).count()

    # چت‌های در انتظار (بدون ادمین)
    pending_rooms = ChatRoom.objects.filter(
        is_active=True,
        admin__isnull=True,
        is_closed=False
    ).order_by('-created_at')

    for room in pending_rooms:
        room.last_message = room.messages.order_by('-created_at').first()

    pending_chats = pending_rooms.count()

    # شمارش کاربران آنلاین
    threshold = timezone.now() - timedelta(minutes=2)
    online_users = UserChatStatus.objects.filter(
        status='online',
        last_seen__gt=threshold
    ).count()

    # چت‌های فعال ادمین
    admin_active_chats = ChatRoom.objects.filter(
        is_active=True,
        admin=request.user,
        is_closed=False
    ).order_by('-updated_at')

    for room in admin_active_chats:
        room.unread_count = room.messages.filter(
            is_read=False,
            sender=room.user
        ).count()
        room.last_message = room.messages.order_by('-created_at').first()

    context = {
        'active_chats': active_chats,
        'pending_chats': pending_chats,
        'online_users': online_users,
        'pending_rooms': pending_rooms,
        'admin_active_chats': admin_active_chats,
    }

    return render(request, 'chat/admin_dashboard.html', context)


@staff_member_required
def api_pending_chats(request):
    """API برای دریافت چت‌های در انتظار"""
    try:
        pending_rooms = ChatRoom.objects.filter(
            is_active=True,
            admin=None,
            is_closed=False
        ).order_by('-created_at')

        html = render_to_string('chat/partials/pending_chats.html', {
            'pending_rooms': pending_rooms,
        }, request=request)

        return JsonResponse({
            'status': 'success',
            'html': html
        })
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'error': str(e)
        })


@staff_member_required
def api_active_chats(request):
    """API برای دریافت چت‌های فعال"""
    try:
        admin_active_chats = ChatRoom.objects.filter(
            is_active=True,
            admin=request.user,
            is_closed=False
        ).order_by('-updated_at')

        # اضافه کردن تعداد پیام‌های خوانده نشده برای هر چت
        for room in admin_active_chats:
            room.unread_count = get_unread_count(room, request.user)

        html = render_to_string('chat/partials/active_chats.html', {
            'admin_active_chats': admin_active_chats,
        }, request=request)

        return JsonResponse({
            'status': 'success',
            'html': html
        })
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'error': str(e)
        })


def get_unread_count(room, user):
    """
    محاسبه تعداد پیام‌های خوانده نشده برای یک کاربر در یک اتاق چت
    """
    # اگر کاربر ادمین است، پیام‌های خوانده نشده از طرف کاربر را بشمار
    if user.is_staff:
        return ChatMessage.objects.filter(
            room=room,
            is_read=False,
            sender=room.user
        ).count()
    # اگر کاربر عادی است، پیام‌های خوانده نشده از طرف ادمین را بشمار
    else:
        return ChatMessage.objects.filter(
            room=room,
            is_read=False,
            sender__is_staff=True
        ).count()


@login_required
def notifications(request):
    user_notifications = Notification.objects.filter(
        user=request.user
    ).order_by('-created_at')[:20]

    context = {
        'notifications': user_notifications
    }
    return render(request, 'chat/notifications.html', context)


@login_required
@require_POST
def mark_notification_read(request, notification_id):
    try:
        notification = get_object_or_404(Notification, id=notification_id, user=request.user)
        notification.is_read = True
        notification.save()
        return JsonResponse({'success': True})
    except Notification.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'نوتیفیکیشن یافت نشد'})


@login_required
def notification_count(request):
    count = Notification.objects.filter(user=request.user, is_read=False).count()
    return JsonResponse({'count': count})


@login_required
def create_support_chat(request):
    if request.user.is_staff:
        return redirect('chat:admin_dashboard')

    # بررسی آیا کاربر قبلاً چت فعال دارد
    existing_active_chat = ChatRoom.objects.filter(
        user=request.user,
        is_active=True,
        is_closed=False
    ).exclude(
        id__in=DeletedChat.objects.filter(user=request.user).values('room_id')
    ).first()

    if existing_active_chat:
        return redirect('chat:chat_room', room_id=existing_active_chat.id)

    # ایجاد چت جدید
    new_chat = ChatRoom.objects.create(
        user=request.user,
        name=f"گفتگوی پشتیبانی {request.user.username}",
        is_active=True
    )

    # ایجاد پیام خوش‌آمدگویی سیستمی
    ChatMessage.objects.create(
        room=new_chat,
        content="به پشتیبانی زیما خوش آمدید. چگونه می‌توانیم به شما کمک کنیم؟",
        message_type="system",
        sender=None  # پیام سیستمی بدون فرستنده
    )

    # اطلاع‌رسانی به ادمین‌ها درباره چت جدید
    admins = User.objects.filter(is_staff=True)
    channel_layer = get_channel_layer()
    for admin in admins:
        try:
            notification_group_name = f'notifications_{admin.id}'
            async_to_sync(channel_layer.group_send)(
                notification_group_name,
                {
                    'type': 'notification_message',
                    'title': 'چت جدید',
                    'message': f'کاربر {request.user.username} یک چت جدید ایجاد کرده است',
                    'data': {
                        'room_id': str(new_chat.id)
                    }
                }
            )
        except Exception as e:
            print(f"Error sending notification to admin {admin.id}: {e}")

    return redirect('chat:chat_room', room_id=new_chat.id)


def api_unread_counts(request):
    if not request.user.is_authenticated:
        return JsonResponse({'success': False, 'error': 'دسترسی غیرمجاز'})

    user_unread_count = 0
    admin_unread_count = 0

    if request.user.is_staff:
        # برای ادمین: پیام‌های خوانده نشده در چت‌های اختصاص داده شده
        admin_unread_count = ChatMessage.objects.filter(
            room__admin=request.user,
            is_read=False,
            sender__is_staff=False
        ).count()

        # اضافه کردن تعداد چت‌های در انتظار
        pending_count = ChatRoom.objects.filter(
            is_active=True,
            admin=None,
            is_closed=False
        ).count()

        admin_unread_count += pending_count
    else:
        # برای کاربر عادی: پیام‌های خوانده نشده در چت‌های خودش
        user_unread_count = ChatMessage.objects.filter(
            room__user=request.user,
            is_read=False
        ).exclude(sender=request.user).count()

    return JsonResponse({
        'success': True,
        'user_unread_count': user_unread_count,
        'admin_unread_count': admin_unread_count
    })


class SetUserOfflineView(View):
    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)

    def post(self, request):
        if not request.user.is_authenticated:
            return JsonResponse({'success': False, 'error': 'Authentication required'}, status=403)

        try:
            status, created = UserChatStatus.objects.get_or_create(user=request.user)
            status.status = 'offline'
            status.save()

            # اطلاع‌رسانی به اتاق‌های چت
            channel_layer = get_channel_layer()
            chat_rooms = self.get_user_chat_rooms(request.user)

            for room in chat_rooms:
                try:
                    async_to_sync(channel_layer.group_send)(
                        f'chat_{room.id}',
                        {
                            'type': 'user_status_update',
                            'user_id': request.user.id,
                            'username': request.user.username,
                            'status': 'offline',
                            'is_staff': request.user.is_staff
                        }
                    )
                except Exception as e:
                    print(f"Error sending status update to room {room.id}: {e}")

            return JsonResponse({'success': True})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)}, status=500)

    def get_user_chat_rooms(self, user):
        """دریافت تمام اتاق‌های چت فعال کاربر"""
        if user.is_staff:
            return list(ChatRoom.objects.filter(admin=user, is_active=True))
        else:
            return list(ChatRoom.objects.filter(user=user, is_active=True))


def check_online_status():
    """بررسی وضعیت آنلاین کاربران و بروزرسانی کاربران غیرفعال به آفلاین"""
    # زمان فعلی منهای 2 دقیقه
    threshold = timezone.now() - timedelta(minutes=2)

    # کاربرانی که آخرین فعالیت آنها قبل از threshold است را آفلاین کن
    offline_users = UserChatStatus.objects.filter(
        status='online',
        last_seen__lt=threshold
    )

    channel_layer = get_channel_layer()

    for user_status in offline_users:
        # تغییر وضعیت به آفلاین
        user_status.status = 'offline'
        user_status.save()

        user = user_status.user

        # دریافت اتاق‌های چت کاربر
        if user.is_staff:
            chat_rooms = ChatRoom.objects.filter(admin=user, is_active=True)
        else:
            chat_rooms = ChatRoom.objects.filter(user=user, is_active=True)

        # اطلاع‌رسانی به تمام اتاق‌های چت
        for room in chat_rooms:
            try:
                async_to_sync(channel_layer.group_send)(
                    f'chat_{room.id}',
                    {
                        'type': 'user_status_update',
                        'user_id': user.id,
                        'username': user.username,
                        'status': 'offline',
                        'is_staff': user.is_staff
                    }
                )
            except Exception as e:
                print(f"Error sending offline status to room {room.id}: {e}")


class SetUserOnlineView(View):
    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)

    def post(self, request):
        if not request.user.is_authenticated:
            return JsonResponse({'success': False, 'error': 'Authentication required'}, status=403)

        try:
            status, created = UserChatStatus.objects.get_or_create(user=request.user)
            old_status = status.status
            status.status = 'online'
            status.last_seen = timezone.now()
            status.save()

            # اگر وضعیت تغییر کرده، به اتاق‌های چت اطلاع بده
            if old_status != 'online' or created:
                channel_layer = get_channel_layer()
                chat_rooms = self.get_user_chat_rooms(request.user)

                for room in chat_rooms:
                    try:
                        async_to_sync(channel_layer.group_send)(
                            f'chat_{room.id}',
                            {
                                'type': 'user_status_update',
                                'user_id': request.user.id,
                                'username': request.user.username,
                                'status': 'online',
                                'is_staff': request.user.is_staff
                            }
                        )
                    except Exception as e:
                        print(f"Error sending status update to room {room.id}: {e}")

            return JsonResponse({'success': True})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)}, status=500)

    def get_user_chat_rooms(self, user):
        """دریافت تمام اتاق‌های چت فعال کاربر"""
        if user.is_staff:
            return list(ChatRoom.objects.filter(admin=user, is_active=True))
        else:
            return list(ChatRoom.objects.filter(user=user, is_active=True))


@login_required
def unread_count(request):
    """دریافت تعداد پیام‌های خوانده نشده"""
    if not request.user.is_authenticated:
        return JsonResponse({'count': 0})

    try:
        if request.user.is_staff:
            # برای ادمین: تعداد کل پیام‌های خوانده نشده در تمام چت‌ها
            admin_unread_count = ChatMessage.objects.filter(
                room__admin=request.user,
                is_read=False,
                sender__is_staff=False  # فقط پیام‌های کاربران عادی
            ).count()

            # اضافه کردن تعداد چت‌های در انتظار
            pending_count = ChatRoom.objects.filter(
                is_active=True,
                admin=None,
                is_closed=False
            ).count()

            count = admin_unread_count + pending_count
        else:
            # برای کاربر عادی: تعداد پیام‌های خوانده نشده در چت‌های خودش
            count = ChatMessage.objects.filter(
                room__user=request.user,
                is_read=False,
                sender__is_staff=True  # فقط پیام‌های ادمین
            ).count()

        return JsonResponse({'count': count})
    except Exception as e:
        return JsonResponse({'count': 0, 'error': str(e)})


@login_required
def get_user_status(request, user_id):
    """API برای دریافت وضعیت آنلاین/آفلاین یک کاربر"""
    try:
        user = User.objects.get(id=user_id)
        status_obj = UserChatStatus.objects.filter(user=user).first()

        if status_obj:
            # بررسی زمان آخرین فعالیت
            threshold = timezone.now() - timedelta(minutes=2)
            if status_obj.last_seen and status_obj.last_seen > threshold:
                return JsonResponse({'status': status_obj.status})
            else:
                return JsonResponse({'status': 'offline'})
        else:
            return JsonResponse({'status': 'offline'})
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

====== FILE: chat/urls.py ======

# chat/urls.py
from django.urls import path
from . import views
from .views import SetUserOfflineView, SetUserOnlineView

app_name = 'chat'

urlpatterns = [
    path('', views.chat_list, name='chat_list'),
    path('start/', views.start_chat, name='start_chat'),
    path('room/<uuid:room_id>/', views.chat_room, name='chat_room'),
    path('support/create/', views.create_support_chat, name='create_support_chat'),
    path('api/user-closed-chats/', views.api_user_closed_chats, name='api_user_closed_chats'),

    # اصلاح مسیر notifications
    path('notifications/', views.notifications, name='notifications'),
    path('notifications/<uuid:notification_id>/read/', views.mark_notification_read, name='mark_notification_read'),
    path('notifications/count/', views.notification_count, name='notification_count'),

    path('admin/dashboard/', views.admin_dashboard, name='admin_dashboard'),
    path('assign-admin/<uuid:room_id>/', views.assign_admin, name='assign_admin'),
    path('close/<uuid:room_id>/', views.close_chat, name='close_chat'),
    path('reopen/<uuid:room_id>/', views.reopen_chat, name='reopen_chat'),
    path('delete/<uuid:room_id>/', views.delete_chat, name='delete_chat'),
    path('mark-read/<int:message_id>/', views.mark_message_as_read, name='mark_message_as_read'),

    path('api/pending-chats/', views.api_pending_chats, name='api_pending_chats'),
    path('api/active-chats/', views.api_active_chats, name='api_active_chats'),
    path('api/unread-counts/', views.api_unread_counts, name='api_unread_counts'),
    path('set-online/', views.SetUserOnlineView.as_view(), name='set_online_status'),
    path('set-offline/', views.SetUserOfflineView.as_view(), name='set_offline_status'),
    path('unread-count/', views.unread_count, name='unread_count'),
    path('user-status/<int:user_id>/', views.get_user_status, name='get_user_status'),
    path('user-close/<uuid:room_id>/', views.user_close_chat, name='user_close_chat'),
    path('admin-close/<uuid:room_id>/', views.admin_close_chat, name='admin_close_chat'),
    path('archive/<uuid:room_id>/', views.archive_chat, name='archive_chat'),
]

====== FILE: chat/tests.py ======

from django.test import TestCase

# Create your tests here.


====== FILE: chat/routing.py ======

from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/chat/(?P<room_id>[^/]+)/$', consumers.ChatConsumer.as_asgi()),
    re_path(r'ws/notifications/$', consumers.NotificationConsumer.as_asgi()),
    re_path(r'ws/online-status/$', consumers.OnlineStatusConsumer.as_asgi()),
]

====== FILE: chat/services.py ======

from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from .models import Notification, UserChatStatus


def send_notification(user, title, message, notification_type='system', data=None):
    """ارسال نوتیفیکیشن به کاربر"""
    if data is None:
        data = {}

    # ذخیره نوتیفیکیشن در دیتابیس
    notification = Notification.objects.create(
        user=user,
        title=title,
        message=message,
        notification_type=notification_type,
        data=data
    )

    # ارسال از طریق WebSocket اگر کاربر آنلاین باشد
    channel_layer = get_channel_layer()

    try:
        # ارسال به گروه نوتیفیکیشن کاربر
        async_to_sync(channel_layer.group_send)(
            f'notifications_{user.id}',
            {
                'type': 'notification',
                'id': str(notification.id),
                'title': title,
                'message': message,
                'notification_type': notification_type,
                'created_at': notification.created_at.isoformat(),
                'data': data
            }
        )
        return True
    except Exception as e:
        print(f"Error sending notification: {e}")
        return False


def send_chat_notification(room, message_obj):
    """ارسال نوتیفیکیشن برای پیام چت جدید"""
    # ارسال نوتیفیکیشن به همه کاربران اتاق به جز فرستنده پیام
    for user in room.participants.all():
        if user != message_obj.user:
            send_notification(
                user=user,
                title="پیام جدید",
                message=f"پیام جدید از {message_obj.user.get_full_name() or message_obj.user.username}: {message_obj.content[:50]}...",
                notification_type='chat_message',
                data={
                    'room_id': str(room.id),
                    'message_id': str(message_obj.id)
                }
            )
    return True



====== FILE: chat/migrations/0006_chatroom_is_closed.py ======

# Generated by Django 5.1.5 on 2025-06-10 08:58

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('chat', '0005_chatroom_is_closed_by_user'),
    ]

    operations = [
        migrations.AddField(
            model_name='chatroom',
            name='is_closed',
            field=models.BooleanField(blank=True, default=False, verbose_name='بسته شده'),
        ),
    ]


====== FILE: chat/migrations/__init__.py ======



====== FILE: chat/migrations/0003_alter_chatroom_is_closed_by_admin.py ======

# Generated by Django 5.1.5 on 2025-06-10 08:51

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('chat', '0002_chatroom_is_closed_by_admin'),
    ]

    operations = [
        migrations.AlterField(
            model_name='chatroom',
            name='is_closed_by_admin',
            field=models.BooleanField(default=False, null=True, verbose_name='بسته شده توسط ادمین'),
        ),
    ]


====== FILE: chat/migrations/0002_chatroom_is_closed_by_admin.py ======

# Generated by Django 5.1.5 on 2025-06-10 08:49

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('chat', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='chatroom',
            name='is_closed_by_admin',
            field=models.BooleanField(default=False, verbose_name='بسته شده توسط ادمین'),
        ),
    ]


====== FILE: chat/migrations/0007_alter_chatroom_is_closed_and_more.py ======

# Generated by Django 5.1.5 on 2025-06-10 08:59

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('chat', '0006_chatroom_is_closed'),
    ]

    operations = [
        migrations.AlterField(
            model_name='chatroom',
            name='is_closed',
            field=models.BooleanField(blank=True, default=False, null=True, verbose_name='بسته شده'),
        ),
        migrations.AlterField(
            model_name='chatroom',
            name='is_closed_by_user',
            field=models.BooleanField(blank=True, default=False, null=True, verbose_name='بسته شده توسط ادمین'),
        ),
    ]


====== FILE: chat/migrations/0002_chatroom_closed_at_chatroom_is_closed_by_admin_and_more.py ======

# Generated by Django 5.1.5 on 2025-06-09 14:14

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('chat', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='chatroom',
            name='closed_at',
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='chatroom',
            name='is_closed_by_admin',
            field=models.BooleanField(default=False),
        ),
        migrations.AddField(
            model_name='chatroom',
            name='is_closed_by_user',
            field=models.BooleanField(default=False),
        ),
    ]


====== FILE: chat/migrations/0004_alter_chatroom_is_closed_by_admin.py ======

# Generated by Django 5.1.5 on 2025-06-10 08:52

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('chat', '0003_alter_chatroom_is_closed_by_admin'),
    ]

    operations = [
        migrations.AlterField(
            model_name='chatroom',
            name='is_closed_by_admin',
            field=models.BooleanField(blank=True, default=False, null=True, verbose_name='بسته شده توسط ادمین'),
        ),
    ]


====== FILE: chat/migrations/0003_chatroom_is_closed.py ======

# Generated by Django 5.1.5 on 2025-06-09 14:49

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('chat', '0002_chatroom_closed_at_chatroom_is_closed_by_admin_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='chatroom',
            name='is_closed',
            field=models.BooleanField(default=False),
        ),
    ]


====== FILE: chat/migrations/0001_initial.py ======

# Generated by Django 5.1.5 on 2025-06-07 10:43

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ChatRoom',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=100, verbose_name='نام اتاق')),
                ('room_type', models.CharField(choices=[('support', 'پشتیبانی'), ('general', 'عمومی'), ('private', 'خصوصی')], default='support', max_length=20, verbose_name='نوع اتاق')),
                ('is_active', models.BooleanField(default=True, verbose_name='فعال')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='تاریخ ایجاد')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='تاریخ بروزرسانی')),
                ('admin', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='admin_chat_rooms', to=settings.AUTH_USER_MODEL)),
                ('participants', models.ManyToManyField(blank=True, related_name='chat_rooms', to=settings.AUTH_USER_MODEL)),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='user_chat_rooms', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'اتاق چت',
                'verbose_name_plural': 'اتاق\u200cهای چت',
                'ordering': ['-updated_at'],
            },
        ),
        migrations.CreateModel(
            name='ChatMessage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('content', models.TextField()),
                ('file', models.FileField(blank=True, null=True, upload_to='chat_files/')),
                ('file_name', models.CharField(blank=True, max_length=255, null=True)),
                ('file_size', models.IntegerField(blank=True, null=True)),
                ('file_type', models.CharField(blank=True, max_length=50, null=True)),
                ('message_type', models.CharField(choices=[('text', 'Text'), ('image', 'Image'), ('file', 'File'), ('system', 'System')], default='text', max_length=10)),
                ('is_read', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('sender', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                ('room', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='messages', to='chat.chatroom')),
            ],
            options={
                'ordering': ['created_at'],
            },
        ),
        migrations.CreateModel(
            name='Notification',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('notification_type', models.CharField(choices=[('chat', 'پیام چت'), ('order', 'بروزرسانی سفارش'), ('product', 'موجود شدن محصول'), ('system', 'سیستم')], max_length=30, verbose_name='نوع نوتیفیکیشن')),
                ('title', models.CharField(max_length=200, verbose_name='عنوان')),
                ('message', models.TextField(verbose_name='پیام')),
                ('data', models.JSONField(blank=True, default=dict, verbose_name='داده\u200cهای اضافی')),
                ('is_read', models.BooleanField(default=False, verbose_name='خوانده شده')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='تاریخ ایجاد')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='notifications', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'نوتیفیکیشن',
                'verbose_name_plural': 'نوتیفیکیشن\u200cها',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='UserChatStatus',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status', models.CharField(choices=[('online', 'آنلاین'), ('away', 'غایب'), ('busy', 'مشغول'), ('offline', 'آفلاین')], default='offline', max_length=20, verbose_name='وضعیت')),
                ('last_seen', models.DateTimeField(auto_now=True, verbose_name='آخرین بازدید')),
                ('is_staff_available', models.BooleanField(default=False, verbose_name='ادمین در دسترس')),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='chat_status', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'وضعیت چت کاربر',
                'verbose_name_plural': 'وضعیت چت کاربران',
            },
        ),
        migrations.CreateModel(
            name='DeletedChat',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('deleted_at', models.DateTimeField(auto_now_add=True)),
                ('room', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='del_messages', to='chat.chatroom')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'unique_together': {('user', 'room')},
            },
        ),
    ]


====== FILE: chat/migrations/0005_chatroom_is_closed_by_user.py ======

# Generated by Django 5.1.5 on 2025-06-10 08:57

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('chat', '0004_alter_chatroom_is_closed_by_admin'),
    ]

    operations = [
        migrations.AddField(
            model_name='chatroom',
            name='is_closed_by_user',
            field=models.BooleanField(blank=True, default=False, verbose_name='بسته شده توسط ادمین'),
        ),
    ]
